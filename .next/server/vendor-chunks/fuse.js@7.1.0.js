"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fuse.js@7.1.0";
exports.ids = ["vendor-chunks/fuse.js@7.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/fuse.js@7.1.0/node_modules/fuse.js/dist/fuse.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/fuse.js@7.1.0/node_modules/fuse.js/dist/fuse.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Fuse)\n/* harmony export */ });\n/**\n * Fuse.js v7.1.0 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2025 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */ function isArray(value) {\n    return !Array.isArray ? getTag(value) === \"[object Array]\" : Array.isArray(value);\n}\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == \"string\") {\n        return value;\n    }\n    let result = value + \"\";\n    return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n}\nfunction toString(value) {\n    return value == null ? \"\" : baseToString(value);\n}\nfunction isString(value) {\n    return typeof value === \"string\";\n}\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n    return value === true || value === false || isObjectLike(value) && getTag(value) == \"[object Boolean]\";\n}\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n    return isObject(value) && value !== null;\n}\nfunction isDefined(value) {\n    return value !== undefined && value !== null;\n}\nfunction isBlank(value) {\n    return !value.trim().length;\n}\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n    return value == null ? value === undefined ? \"[object Undefined]\" : \"[object Null]\" : Object.prototype.toString.call(value);\n}\nconst EXTENDED_SEARCH_UNAVAILABLE = \"Extended search is not available\";\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key)=>`Invalid value for key ${key}`;\nconst PATTERN_LENGTH_TOO_LARGE = (max)=>`Pattern length exceeds max of ${max}.`;\nconst MISSING_KEY_PROPERTY = (name)=>`Missing ${name} property in key`;\nconst INVALID_KEY_WEIGHT_VALUE = (key)=>`Property 'weight' in key '${key}' must be a positive integer`;\nconst hasOwn = Object.prototype.hasOwnProperty;\nclass KeyStore {\n    constructor(keys){\n        this._keys = [];\n        this._keyMap = {};\n        let totalWeight = 0;\n        keys.forEach((key)=>{\n            let obj = createKey(key);\n            this._keys.push(obj);\n            this._keyMap[obj.id] = obj;\n            totalWeight += obj.weight;\n        });\n        // Normalize weights so that their sum is equal to 1\n        this._keys.forEach((key)=>{\n            key.weight /= totalWeight;\n        });\n    }\n    get(keyId) {\n        return this._keyMap[keyId];\n    }\n    keys() {\n        return this._keys;\n    }\n    toJSON() {\n        return JSON.stringify(this._keys);\n    }\n}\nfunction createKey(key) {\n    let path = null;\n    let id = null;\n    let src = null;\n    let weight = 1;\n    let getFn = null;\n    if (isString(key) || isArray(key)) {\n        src = key;\n        path = createKeyPath(key);\n        id = createKeyId(key);\n    } else {\n        if (!hasOwn.call(key, \"name\")) {\n            throw new Error(MISSING_KEY_PROPERTY(\"name\"));\n        }\n        const name = key.name;\n        src = name;\n        if (hasOwn.call(key, \"weight\")) {\n            weight = key.weight;\n            if (weight <= 0) {\n                throw new Error(INVALID_KEY_WEIGHT_VALUE(name));\n            }\n        }\n        path = createKeyPath(name);\n        id = createKeyId(name);\n        getFn = key.getFn;\n    }\n    return {\n        path,\n        id,\n        weight,\n        src,\n        getFn\n    };\n}\nfunction createKeyPath(key) {\n    return isArray(key) ? key : key.split(\".\");\n}\nfunction createKeyId(key) {\n    return isArray(key) ? key.join(\".\") : key;\n}\nfunction get(obj, path) {\n    let list = [];\n    let arr = false;\n    const deepGet = (obj, path, index)=>{\n        if (!isDefined(obj)) {\n            return;\n        }\n        if (!path[index]) {\n            // If there's no path left, we've arrived at the object we care about.\n            list.push(obj);\n        } else {\n            let key = path[index];\n            const value = obj[key];\n            if (!isDefined(value)) {\n                return;\n            }\n            // If we're at the last value in the path, and if it's a string/number/bool,\n            // add it to the list\n            if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {\n                list.push(toString(value));\n            } else if (isArray(value)) {\n                arr = true;\n                // Search each item in the array.\n                for(let i = 0, len = value.length; i < len; i += 1){\n                    deepGet(value[i], path, index + 1);\n                }\n            } else if (path.length) {\n                // An object. Recurse further.\n                deepGet(value, path, index + 1);\n            }\n        }\n    };\n    // Backwards compatibility (since path used to be a string)\n    deepGet(obj, isString(path) ? path.split(\".\") : path, 0);\n    return arr ? list : list[0];\n}\nconst MatchOptions = {\n    // Whether the matches should be included in the result set. When `true`, each record in the result\n    // set will include the indices of the matched characters.\n    // These can consequently be used for highlighting purposes.\n    includeMatches: false,\n    // When `true`, the matching function will continue to the end of a search pattern even if\n    // a perfect match has already been located in the string.\n    findAllMatches: false,\n    // Minimum number of characters that must be matched before a result is considered a match\n    minMatchCharLength: 1\n};\nconst BasicOptions = {\n    // When `true`, the algorithm continues searching to the end of the input even if a perfect\n    // match is found before the end of the same input.\n    isCaseSensitive: false,\n    // When `true`, the algorithm will ignore diacritics (accents) in comparisons\n    ignoreDiacritics: false,\n    // When true, the matching function will continue to the end of a search pattern even if\n    includeScore: false,\n    // List of properties that will be searched. This also supports nested properties.\n    keys: [],\n    // Whether to sort the result list, by score\n    shouldSort: true,\n    // Default sort function: sort by ascending score, ascending index\n    sortFn: (a, b)=>a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1\n};\nconst FuzzyOptions = {\n    // Approximately where in the text is the pattern expected to be found?\n    location: 0,\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold: 0.6,\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance: 100\n};\nconst AdvancedOptions = {\n    // When `true`, it enables the use of unix-like search commands\n    useExtendedSearch: false,\n    // The get function to use when fetching an object's properties.\n    // The default will search nested paths *ie foo.bar.baz*\n    getFn: get,\n    // When `true`, search will ignore `location` and `distance`, so it won't matter\n    // where in the string the pattern appears.\n    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n    ignoreLocation: false,\n    // When `true`, the calculation for the relevance score (used for sorting) will\n    // ignore the field-length norm.\n    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n    ignoreFieldNorm: false,\n    // The weight to determine how much field length norm effects scoring.\n    fieldNormWeight: 1\n};\nvar Config = {\n    ...BasicOptions,\n    ...MatchOptions,\n    ...FuzzyOptions,\n    ...AdvancedOptions\n};\nconst SPACE = /[^ ]+/g;\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n    const cache = new Map();\n    const m = Math.pow(10, mantissa);\n    return {\n        get (value) {\n            const numTokens = value.match(SPACE).length;\n            if (cache.has(numTokens)) {\n                return cache.get(numTokens);\n            }\n            // Default function is 1/sqrt(x), weight makes that variable\n            const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n            // In place of `toFixed(mantissa)`, for faster computation\n            const n = parseFloat(Math.round(norm * m) / m);\n            cache.set(numTokens, n);\n            return n;\n        },\n        clear () {\n            cache.clear();\n        }\n    };\n}\nclass FuseIndex {\n    constructor({ getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}){\n        this.norm = norm(fieldNormWeight, 3);\n        this.getFn = getFn;\n        this.isCreated = false;\n        this.setIndexRecords();\n    }\n    setSources(docs = []) {\n        this.docs = docs;\n    }\n    setIndexRecords(records = []) {\n        this.records = records;\n    }\n    setKeys(keys = []) {\n        this.keys = keys;\n        this._keysMap = {};\n        keys.forEach((key, idx)=>{\n            this._keysMap[key.id] = idx;\n        });\n    }\n    create() {\n        if (this.isCreated || !this.docs.length) {\n            return;\n        }\n        this.isCreated = true;\n        // List is Array<String>\n        if (isString(this.docs[0])) {\n            this.docs.forEach((doc, docIndex)=>{\n                this._addString(doc, docIndex);\n            });\n        } else {\n            // List is Array<Object>\n            this.docs.forEach((doc, docIndex)=>{\n                this._addObject(doc, docIndex);\n            });\n        }\n        this.norm.clear();\n    }\n    // Adds a doc to the end of the index\n    add(doc) {\n        const idx = this.size();\n        if (isString(doc)) {\n            this._addString(doc, idx);\n        } else {\n            this._addObject(doc, idx);\n        }\n    }\n    // Removes the doc at the specified index of the index\n    removeAt(idx) {\n        this.records.splice(idx, 1);\n        // Change ref index of every subsquent doc\n        for(let i = idx, len = this.size(); i < len; i += 1){\n            this.records[i].i -= 1;\n        }\n    }\n    getValueForItemAtKeyId(item, keyId) {\n        return item[this._keysMap[keyId]];\n    }\n    size() {\n        return this.records.length;\n    }\n    _addString(doc, docIndex) {\n        if (!isDefined(doc) || isBlank(doc)) {\n            return;\n        }\n        let record = {\n            v: doc,\n            i: docIndex,\n            n: this.norm.get(doc)\n        };\n        this.records.push(record);\n    }\n    _addObject(doc, docIndex) {\n        let record = {\n            i: docIndex,\n            $: {}\n        };\n        // Iterate over every key (i.e, path), and fetch the value at that key\n        this.keys.forEach((key, keyIndex)=>{\n            let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n            if (!isDefined(value)) {\n                return;\n            }\n            if (isArray(value)) {\n                let subRecords = [];\n                const stack = [\n                    {\n                        nestedArrIndex: -1,\n                        value\n                    }\n                ];\n                while(stack.length){\n                    const { nestedArrIndex, value } = stack.pop();\n                    if (!isDefined(value)) {\n                        continue;\n                    }\n                    if (isString(value) && !isBlank(value)) {\n                        let subRecord = {\n                            v: value,\n                            i: nestedArrIndex,\n                            n: this.norm.get(value)\n                        };\n                        subRecords.push(subRecord);\n                    } else if (isArray(value)) {\n                        value.forEach((item, k)=>{\n                            stack.push({\n                                nestedArrIndex: k,\n                                value: item\n                            });\n                        });\n                    } else ;\n                }\n                record.$[keyIndex] = subRecords;\n            } else if (isString(value) && !isBlank(value)) {\n                let subRecord = {\n                    v: value,\n                    n: this.norm.get(value)\n                };\n                record.$[keyIndex] = subRecord;\n            }\n        });\n        this.records.push(record);\n    }\n    toJSON() {\n        return {\n            keys: this.keys,\n            records: this.records\n        };\n    }\n}\nfunction createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n    const myIndex = new FuseIndex({\n        getFn,\n        fieldNormWeight\n    });\n    myIndex.setKeys(keys.map(createKey));\n    myIndex.setSources(docs);\n    myIndex.create();\n    return myIndex;\n}\nfunction parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n    const { keys, records } = data;\n    const myIndex = new FuseIndex({\n        getFn,\n        fieldNormWeight\n    });\n    myIndex.setKeys(keys);\n    myIndex.setIndexRecords(records);\n    return myIndex;\n}\nfunction computeScore$1(pattern, { errors = 0, currentLocation = 0, expectedLocation = 0, distance = Config.distance, ignoreLocation = Config.ignoreLocation } = {}) {\n    const accuracy = errors / pattern.length;\n    if (ignoreLocation) {\n        return accuracy;\n    }\n    const proximity = Math.abs(expectedLocation - currentLocation);\n    if (!distance) {\n        // Dodge divide by zero error.\n        return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + proximity / distance;\n}\nfunction convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {\n    let indices = [];\n    let start = -1;\n    let end = -1;\n    let i = 0;\n    for(let len = matchmask.length; i < len; i += 1){\n        let match = matchmask[i];\n        if (match && start === -1) {\n            start = i;\n        } else if (!match && start !== -1) {\n            end = i - 1;\n            if (end - start + 1 >= minMatchCharLength) {\n                indices.push([\n                    start,\n                    end\n                ]);\n            }\n            start = -1;\n        }\n    }\n    // (i-1 - start) + 1 => i - start\n    if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n        indices.push([\n            start,\n            i - 1\n        ]);\n    }\n    return indices;\n}\n// Machine word size\nconst MAX_BITS = 32;\nfunction search(text, pattern, patternAlphabet, { location = Config.location, distance = Config.distance, threshold = Config.threshold, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, includeMatches = Config.includeMatches, ignoreLocation = Config.ignoreLocation } = {}) {\n    if (pattern.length > MAX_BITS) {\n        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\n    }\n    const patternLen = pattern.length;\n    // Set starting location at beginning text and initialize the alphabet.\n    const textLen = text.length;\n    // Handle the case when location > text.length\n    const expectedLocation = Math.max(0, Math.min(location, textLen));\n    // Highest score beyond which we give up.\n    let currentThreshold = threshold;\n    // Is there a nearby exact match? (speedup)\n    let bestLocation = expectedLocation;\n    // Performance: only computer matches when the minMatchCharLength > 1\n    // OR if `includeMatches` is true.\n    const computeMatches = minMatchCharLength > 1 || includeMatches;\n    // A mask of the matches, used for building the indices\n    const matchMask = computeMatches ? Array(textLen) : [];\n    let index;\n    // Get all exact matches, here for speed up\n    while((index = text.indexOf(pattern, bestLocation)) > -1){\n        let score = computeScore$1(pattern, {\n            currentLocation: index,\n            expectedLocation,\n            distance,\n            ignoreLocation\n        });\n        currentThreshold = Math.min(score, currentThreshold);\n        bestLocation = index + patternLen;\n        if (computeMatches) {\n            let i = 0;\n            while(i < patternLen){\n                matchMask[index + i] = 1;\n                i += 1;\n            }\n        }\n    }\n    // Reset the best location\n    bestLocation = -1;\n    let lastBitArr = [];\n    let finalScore = 1;\n    let binMax = patternLen + textLen;\n    const mask = 1 << patternLen - 1;\n    for(let i = 0; i < patternLen; i += 1){\n        // Scan for the best match; each iteration allows for one more error.\n        // Run a binary search to determine how far from the match location we can stray\n        // at this error level.\n        let binMin = 0;\n        let binMid = binMax;\n        while(binMin < binMid){\n            const score = computeScore$1(pattern, {\n                errors: i,\n                currentLocation: expectedLocation + binMid,\n                expectedLocation,\n                distance,\n                ignoreLocation\n            });\n            if (score <= currentThreshold) {\n                binMin = binMid;\n            } else {\n                binMax = binMid;\n            }\n            binMid = Math.floor((binMax - binMin) / 2 + binMin);\n        }\n        // Use the result from this iteration as the maximum for the next.\n        binMax = binMid;\n        let start = Math.max(1, expectedLocation - binMid + 1);\n        let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n        // Initialize the bit array\n        let bitArr = Array(finish + 2);\n        bitArr[finish + 1] = (1 << i) - 1;\n        for(let j = finish; j >= start; j -= 1){\n            let currentLocation = j - 1;\n            let charMatch = patternAlphabet[text.charAt(currentLocation)];\n            if (computeMatches) {\n                // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n                matchMask[currentLocation] = +!!charMatch;\n            }\n            // First pass: exact match\n            bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n            // Subsequent passes: fuzzy match\n            if (i) {\n                bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n            }\n            if (bitArr[j] & mask) {\n                finalScore = computeScore$1(pattern, {\n                    errors: i,\n                    currentLocation,\n                    expectedLocation,\n                    distance,\n                    ignoreLocation\n                });\n                // This match will almost certainly be better than any existing match.\n                // But check anyway.\n                if (finalScore <= currentThreshold) {\n                    // Indeed it is\n                    currentThreshold = finalScore;\n                    bestLocation = currentLocation;\n                    // Already passed `loc`, downhill from here on in.\n                    if (bestLocation <= expectedLocation) {\n                        break;\n                    }\n                    // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n                    start = Math.max(1, 2 * expectedLocation - bestLocation);\n                }\n            }\n        }\n        // No hope for a (better) match at greater error levels.\n        const score = computeScore$1(pattern, {\n            errors: i + 1,\n            currentLocation: expectedLocation,\n            expectedLocation,\n            distance,\n            ignoreLocation\n        });\n        if (score > currentThreshold) {\n            break;\n        }\n        lastBitArr = bitArr;\n    }\n    const result = {\n        isMatch: bestLocation >= 0,\n        // Count exact matches (those with a score of 0) to be \"almost\" exact\n        score: Math.max(0.001, finalScore)\n    };\n    if (computeMatches) {\n        const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n        if (!indices.length) {\n            result.isMatch = false;\n        } else if (includeMatches) {\n            result.indices = indices;\n        }\n    }\n    return result;\n}\nfunction createPatternAlphabet(pattern) {\n    let mask = {};\n    for(let i = 0, len = pattern.length; i < len; i += 1){\n        const char = pattern.charAt(i);\n        mask[char] = (mask[char] || 0) | 1 << len - i - 1;\n    }\n    return mask;\n}\nconst stripDiacritics = String.prototype.normalize ? (str)=>str.normalize(\"NFD\").replace(/[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C04\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F]/g, \"\") : (str)=>str;\nclass BitapSearch {\n    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreDiacritics = Config.ignoreDiacritics, ignoreLocation = Config.ignoreLocation } = {}){\n        this.options = {\n            location,\n            threshold,\n            distance,\n            includeMatches,\n            findAllMatches,\n            minMatchCharLength,\n            isCaseSensitive,\n            ignoreDiacritics,\n            ignoreLocation\n        };\n        pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n        pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;\n        this.pattern = pattern;\n        this.chunks = [];\n        if (!this.pattern.length) {\n            return;\n        }\n        const addChunk = (pattern, startIndex)=>{\n            this.chunks.push({\n                pattern,\n                alphabet: createPatternAlphabet(pattern),\n                startIndex\n            });\n        };\n        const len = this.pattern.length;\n        if (len > MAX_BITS) {\n            let i = 0;\n            const remainder = len % MAX_BITS;\n            const end = len - remainder;\n            while(i < end){\n                addChunk(this.pattern.substr(i, MAX_BITS), i);\n                i += MAX_BITS;\n            }\n            if (remainder) {\n                const startIndex = len - MAX_BITS;\n                addChunk(this.pattern.substr(startIndex), startIndex);\n            }\n        } else {\n            addChunk(this.pattern, 0);\n        }\n    }\n    searchIn(text) {\n        const { isCaseSensitive, ignoreDiacritics, includeMatches } = this.options;\n        text = isCaseSensitive ? text : text.toLowerCase();\n        text = ignoreDiacritics ? stripDiacritics(text) : text;\n        // Exact match\n        if (this.pattern === text) {\n            let result = {\n                isMatch: true,\n                score: 0\n            };\n            if (includeMatches) {\n                result.indices = [\n                    [\n                        0,\n                        text.length - 1\n                    ]\n                ];\n            }\n            return result;\n        }\n        // Otherwise, use Bitap algorithm\n        const { location, distance, threshold, findAllMatches, minMatchCharLength, ignoreLocation } = this.options;\n        let allIndices = [];\n        let totalScore = 0;\n        let hasMatches = false;\n        this.chunks.forEach(({ pattern, alphabet, startIndex })=>{\n            const { isMatch, score, indices } = search(text, pattern, alphabet, {\n                location: location + startIndex,\n                distance,\n                threshold,\n                findAllMatches,\n                minMatchCharLength,\n                includeMatches,\n                ignoreLocation\n            });\n            if (isMatch) {\n                hasMatches = true;\n            }\n            totalScore += score;\n            if (isMatch && indices) {\n                allIndices = [\n                    ...allIndices,\n                    ...indices\n                ];\n            }\n        });\n        let result = {\n            isMatch: hasMatches,\n            score: hasMatches ? totalScore / this.chunks.length : 1\n        };\n        if (hasMatches && includeMatches) {\n            result.indices = allIndices;\n        }\n        return result;\n    }\n}\nclass BaseMatch {\n    constructor(pattern){\n        this.pattern = pattern;\n    }\n    static isMultiMatch(pattern) {\n        return getMatch(pattern, this.multiRegex);\n    }\n    static isSingleMatch(pattern) {\n        return getMatch(pattern, this.singleRegex);\n    }\n    search() {}\n}\nfunction getMatch(pattern, exp) {\n    const matches = pattern.match(exp);\n    return matches ? matches[1] : null;\n}\n// Token: 'file\nclass ExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"exact\";\n    }\n    static get multiRegex() {\n        return /^=\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^=(.*)$/;\n    }\n    search(text) {\n        const isMatch = text === this.pattern;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                this.pattern.length - 1\n            ]\n        };\n    }\n}\n// Token: !fire\nclass InverseExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"inverse-exact\";\n    }\n    static get multiRegex() {\n        return /^!\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^!(.*)$/;\n    }\n    search(text) {\n        const index = text.indexOf(this.pattern);\n        const isMatch = index === -1;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: ^file\nclass PrefixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"prefix-exact\";\n    }\n    static get multiRegex() {\n        return /^\\^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^\\^(.*)$/;\n    }\n    search(text) {\n        const isMatch = text.startsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                this.pattern.length - 1\n            ]\n        };\n    }\n}\n// Token: !^fire\nclass InversePrefixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"inverse-prefix-exact\";\n    }\n    static get multiRegex() {\n        return /^!\\^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^!\\^(.*)$/;\n    }\n    search(text) {\n        const isMatch = !text.startsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: .file$\nclass SuffixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"suffix-exact\";\n    }\n    static get multiRegex() {\n        return /^\"(.*)\"\\$$/;\n    }\n    static get singleRegex() {\n        return /^(.*)\\$$/;\n    }\n    search(text) {\n        const isMatch = text.endsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                text.length - this.pattern.length,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: !.file$\nclass InverseSuffixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"inverse-suffix-exact\";\n    }\n    static get multiRegex() {\n        return /^!\"(.*)\"\\$$/;\n    }\n    static get singleRegex() {\n        return /^!(.*)\\$$/;\n    }\n    search(text) {\n        const isMatch = !text.endsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\nclass FuzzyMatch extends BaseMatch {\n    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreDiacritics = Config.ignoreDiacritics, ignoreLocation = Config.ignoreLocation } = {}){\n        super(pattern);\n        this._bitapSearch = new BitapSearch(pattern, {\n            location,\n            threshold,\n            distance,\n            includeMatches,\n            findAllMatches,\n            minMatchCharLength,\n            isCaseSensitive,\n            ignoreDiacritics,\n            ignoreLocation\n        });\n    }\n    static get type() {\n        return \"fuzzy\";\n    }\n    static get multiRegex() {\n        return /^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^(.*)$/;\n    }\n    search(text) {\n        return this._bitapSearch.searchIn(text);\n    }\n}\n// Token: 'file\nclass IncludeMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"include\";\n    }\n    static get multiRegex() {\n        return /^'\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^'(.*)$/;\n    }\n    search(text) {\n        let location = 0;\n        let index;\n        const indices = [];\n        const patternLen = this.pattern.length;\n        // Get all exact matches\n        while((index = text.indexOf(this.pattern, location)) > -1){\n            location = index + patternLen;\n            indices.push([\n                index,\n                location - 1\n            ]);\n        }\n        const isMatch = !!indices.length;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices\n        };\n    }\n}\n// â—Order is important. DO NOT CHANGE.\nconst searchers = [\n    ExactMatch,\n    IncludeMatch,\n    PrefixExactMatch,\n    InversePrefixExactMatch,\n    InverseSuffixExactMatch,\n    SuffixExactMatch,\n    InverseExactMatch,\n    FuzzyMatch\n];\nconst searchersLen = searchers.length;\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = \"|\";\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n    return pattern.split(OR_TOKEN).map((item)=>{\n        let query = item.trim().split(SPACE_RE).filter((item)=>item && !!item.trim());\n        let results = [];\n        for(let i = 0, len = query.length; i < len; i += 1){\n            const queryItem = query[i];\n            // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n            let found = false;\n            let idx = -1;\n            while(!found && ++idx < searchersLen){\n                const searcher = searchers[idx];\n                let token = searcher.isMultiMatch(queryItem);\n                if (token) {\n                    results.push(new searcher(token, options));\n                    found = true;\n                }\n            }\n            if (found) {\n                continue;\n            }\n            // 2. Handle single query matches (i.e, once that are *not* quoted)\n            idx = -1;\n            while(++idx < searchersLen){\n                const searcher = searchers[idx];\n                let token = searcher.isSingleMatch(queryItem);\n                if (token) {\n                    results.push(new searcher(token, options));\n                    break;\n                }\n            }\n        }\n        return results;\n    });\n}\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([\n    FuzzyMatch.type,\n    IncludeMatch.type\n]);\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */ class ExtendedSearch {\n    constructor(pattern, { isCaseSensitive = Config.isCaseSensitive, ignoreDiacritics = Config.ignoreDiacritics, includeMatches = Config.includeMatches, minMatchCharLength = Config.minMatchCharLength, ignoreLocation = Config.ignoreLocation, findAllMatches = Config.findAllMatches, location = Config.location, threshold = Config.threshold, distance = Config.distance } = {}){\n        this.query = null;\n        this.options = {\n            isCaseSensitive,\n            ignoreDiacritics,\n            includeMatches,\n            minMatchCharLength,\n            findAllMatches,\n            ignoreLocation,\n            location,\n            threshold,\n            distance\n        };\n        pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n        pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;\n        this.pattern = pattern;\n        this.query = parseQuery(this.pattern, this.options);\n    }\n    static condition(_, options) {\n        return options.useExtendedSearch;\n    }\n    searchIn(text) {\n        const query = this.query;\n        if (!query) {\n            return {\n                isMatch: false,\n                score: 1\n            };\n        }\n        const { includeMatches, isCaseSensitive, ignoreDiacritics } = this.options;\n        text = isCaseSensitive ? text : text.toLowerCase();\n        text = ignoreDiacritics ? stripDiacritics(text) : text;\n        let numMatches = 0;\n        let allIndices = [];\n        let totalScore = 0;\n        // ORs\n        for(let i = 0, qLen = query.length; i < qLen; i += 1){\n            const searchers = query[i];\n            // Reset indices\n            allIndices.length = 0;\n            numMatches = 0;\n            // ANDs\n            for(let j = 0, pLen = searchers.length; j < pLen; j += 1){\n                const searcher = searchers[j];\n                const { isMatch, indices, score } = searcher.search(text);\n                if (isMatch) {\n                    numMatches += 1;\n                    totalScore += score;\n                    if (includeMatches) {\n                        const type = searcher.constructor.type;\n                        if (MultiMatchSet.has(type)) {\n                            allIndices = [\n                                ...allIndices,\n                                ...indices\n                            ];\n                        } else {\n                            allIndices.push(indices);\n                        }\n                    }\n                } else {\n                    totalScore = 0;\n                    numMatches = 0;\n                    allIndices.length = 0;\n                    break;\n                }\n            }\n            // OR condition, so if TRUE, return\n            if (numMatches) {\n                let result = {\n                    isMatch: true,\n                    score: totalScore / numMatches\n                };\n                if (includeMatches) {\n                    result.indices = allIndices;\n                }\n                return result;\n            }\n        }\n        // Nothing was matched\n        return {\n            isMatch: false,\n            score: 1\n        };\n    }\n}\nconst registeredSearchers = [];\nfunction register(...args) {\n    registeredSearchers.push(...args);\n}\nfunction createSearcher(pattern, options) {\n    for(let i = 0, len = registeredSearchers.length; i < len; i += 1){\n        let searcherClass = registeredSearchers[i];\n        if (searcherClass.condition(pattern, options)) {\n            return new searcherClass(pattern, options);\n        }\n    }\n    return new BitapSearch(pattern, options);\n}\nconst LogicalOperator = {\n    AND: \"$and\",\n    OR: \"$or\"\n};\nconst KeyType = {\n    PATH: \"$path\",\n    PATTERN: \"$val\"\n};\nconst isExpression = (query)=>!!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\nconst isPath = (query)=>!!query[KeyType.PATH];\nconst isLeaf = (query)=>!isArray(query) && isObject(query) && !isExpression(query);\nconst convertToExplicit = (query)=>({\n        [LogicalOperator.AND]: Object.keys(query).map((key)=>({\n                [key]: query[key]\n            }))\n    });\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n    const next = (query)=>{\n        let keys = Object.keys(query);\n        const isQueryPath = isPath(query);\n        if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n            return next(convertToExplicit(query));\n        }\n        if (isLeaf(query)) {\n            const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n            const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n            if (!isString(pattern)) {\n                throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\n            }\n            const obj = {\n                keyId: createKeyId(key),\n                pattern\n            };\n            if (auto) {\n                obj.searcher = createSearcher(pattern, options);\n            }\n            return obj;\n        }\n        let node = {\n            children: [],\n            operator: keys[0]\n        };\n        keys.forEach((key)=>{\n            const value = query[key];\n            if (isArray(value)) {\n                value.forEach((item)=>{\n                    node.children.push(next(item));\n                });\n            }\n        });\n        return node;\n    };\n    if (!isExpression(query)) {\n        query = convertToExplicit(query);\n    }\n    return next(query);\n}\n// Practical scoring function\nfunction computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {\n    results.forEach((result)=>{\n        let totalScore = 1;\n        result.matches.forEach(({ key, norm, score })=>{\n            const weight = key ? key.weight : null;\n            totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));\n        });\n        result.score = totalScore;\n    });\n}\nfunction transformMatches(result, data) {\n    const matches = result.matches;\n    data.matches = [];\n    if (!isDefined(matches)) {\n        return;\n    }\n    matches.forEach((match)=>{\n        if (!isDefined(match.indices) || !match.indices.length) {\n            return;\n        }\n        const { indices, value } = match;\n        let obj = {\n            indices,\n            value\n        };\n        if (match.key) {\n            obj.key = match.key.src;\n        }\n        if (match.idx > -1) {\n            obj.refIndex = match.idx;\n        }\n        data.matches.push(obj);\n    });\n}\nfunction transformScore(result, data) {\n    data.score = result.score;\n}\nfunction format(results, docs, { includeMatches = Config.includeMatches, includeScore = Config.includeScore } = {}) {\n    const transformers = [];\n    if (includeMatches) transformers.push(transformMatches);\n    if (includeScore) transformers.push(transformScore);\n    return results.map((result)=>{\n        const { idx } = result;\n        const data = {\n            item: docs[idx],\n            refIndex: idx\n        };\n        if (transformers.length) {\n            transformers.forEach((transformer)=>{\n                transformer(result, data);\n            });\n        }\n        return data;\n    });\n}\nclass Fuse {\n    constructor(docs, options = {}, index){\n        this.options = {\n            ...Config,\n            ...options\n        };\n        if (this.options.useExtendedSearch && !true) {}\n        this._keyStore = new KeyStore(this.options.keys);\n        this.setCollection(docs, index);\n    }\n    setCollection(docs, index) {\n        this._docs = docs;\n        if (index && !(index instanceof FuseIndex)) {\n            throw new Error(INCORRECT_INDEX_TYPE);\n        }\n        this._myIndex = index || createIndex(this.options.keys, this._docs, {\n            getFn: this.options.getFn,\n            fieldNormWeight: this.options.fieldNormWeight\n        });\n    }\n    add(doc) {\n        if (!isDefined(doc)) {\n            return;\n        }\n        this._docs.push(doc);\n        this._myIndex.add(doc);\n    }\n    remove(predicate = ()=>false) {\n        const results = [];\n        for(let i = 0, len = this._docs.length; i < len; i += 1){\n            const doc = this._docs[i];\n            if (predicate(doc, i)) {\n                this.removeAt(i);\n                i -= 1;\n                len -= 1;\n                results.push(doc);\n            }\n        }\n        return results;\n    }\n    removeAt(idx) {\n        this._docs.splice(idx, 1);\n        this._myIndex.removeAt(idx);\n    }\n    getIndex() {\n        return this._myIndex;\n    }\n    search(query, { limit = -1 } = {}) {\n        const { includeMatches, includeScore, shouldSort, sortFn, ignoreFieldNorm } = this.options;\n        let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\n        computeScore(results, {\n            ignoreFieldNorm\n        });\n        if (shouldSort) {\n            results.sort(sortFn);\n        }\n        if (isNumber(limit) && limit > -1) {\n            results = results.slice(0, limit);\n        }\n        return format(results, this._docs, {\n            includeMatches,\n            includeScore\n        });\n    }\n    _searchStringList(query) {\n        const searcher = createSearcher(query, this.options);\n        const { records } = this._myIndex;\n        const results = [];\n        // Iterate over every string in the index\n        records.forEach(({ v: text, i: idx, n: norm })=>{\n            if (!isDefined(text)) {\n                return;\n            }\n            const { isMatch, score, indices } = searcher.searchIn(text);\n            if (isMatch) {\n                results.push({\n                    item: text,\n                    idx,\n                    matches: [\n                        {\n                            score,\n                            value: text,\n                            norm,\n                            indices\n                        }\n                    ]\n                });\n            }\n        });\n        return results;\n    }\n    _searchLogical(query) {\n        const expression = parse(query, this.options);\n        const evaluate = (node, item, idx)=>{\n            if (!node.children) {\n                const { keyId, searcher } = node;\n                const matches = this._findMatches({\n                    key: this._keyStore.get(keyId),\n                    value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n                    searcher\n                });\n                if (matches && matches.length) {\n                    return [\n                        {\n                            idx,\n                            item,\n                            matches\n                        }\n                    ];\n                }\n                return [];\n            }\n            const res = [];\n            for(let i = 0, len = node.children.length; i < len; i += 1){\n                const child = node.children[i];\n                const result = evaluate(child, item, idx);\n                if (result.length) {\n                    res.push(...result);\n                } else if (node.operator === LogicalOperator.AND) {\n                    return [];\n                }\n            }\n            return res;\n        };\n        const records = this._myIndex.records;\n        const resultMap = {};\n        const results = [];\n        records.forEach(({ $: item, i: idx })=>{\n            if (isDefined(item)) {\n                let expResults = evaluate(expression, item, idx);\n                if (expResults.length) {\n                    // Dedupe when adding\n                    if (!resultMap[idx]) {\n                        resultMap[idx] = {\n                            idx,\n                            item,\n                            matches: []\n                        };\n                        results.push(resultMap[idx]);\n                    }\n                    expResults.forEach(({ matches })=>{\n                        resultMap[idx].matches.push(...matches);\n                    });\n                }\n            }\n        });\n        return results;\n    }\n    _searchObjectList(query) {\n        const searcher = createSearcher(query, this.options);\n        const { keys, records } = this._myIndex;\n        const results = [];\n        // List is Array<Object>\n        records.forEach(({ $: item, i: idx })=>{\n            if (!isDefined(item)) {\n                return;\n            }\n            let matches = [];\n            // Iterate over every key (i.e, path), and fetch the value at that key\n            keys.forEach((key, keyIndex)=>{\n                matches.push(...this._findMatches({\n                    key,\n                    value: item[keyIndex],\n                    searcher\n                }));\n            });\n            if (matches.length) {\n                results.push({\n                    idx,\n                    item,\n                    matches\n                });\n            }\n        });\n        return results;\n    }\n    _findMatches({ key, value, searcher }) {\n        if (!isDefined(value)) {\n            return [];\n        }\n        let matches = [];\n        if (isArray(value)) {\n            value.forEach(({ v: text, i: idx, n: norm })=>{\n                if (!isDefined(text)) {\n                    return;\n                }\n                const { isMatch, score, indices } = searcher.searchIn(text);\n                if (isMatch) {\n                    matches.push({\n                        score,\n                        key,\n                        value: text,\n                        idx,\n                        norm,\n                        indices\n                    });\n                }\n            });\n        } else {\n            const { v: text, n: norm } = value;\n            const { isMatch, score, indices } = searcher.searchIn(text);\n            if (isMatch) {\n                matches.push({\n                    score,\n                    key,\n                    value: text,\n                    norm,\n                    indices\n                });\n            }\n        }\n        return matches;\n    }\n}\nFuse.version = \"7.1.0\";\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n{\n    Fuse.parseQuery = parse;\n}{\n    register(ExtendedSearch);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZnVzZS5qc0A3LjEuMC9ub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBRUQsU0FBU0EsUUFBUUMsS0FBSztJQUNwQixPQUFPLENBQUNDLE1BQU1GLE9BQU8sR0FDakJHLE9BQU9GLFdBQVcsbUJBQ2xCQyxNQUFNRixPQUFPLENBQUNDO0FBQ3BCO0FBRUEsdUZBQXVGO0FBQ3ZGLE1BQU1HLFdBQVcsSUFBSTtBQUNyQixTQUFTQyxhQUFhSixLQUFLO0lBQ3pCLDBFQUEwRTtJQUMxRSxJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSUssU0FBU0wsUUFBUTtJQUNyQixPQUFPSyxVQUFVLE9BQU8sSUFBSUwsU0FBUyxDQUFDRyxXQUFXLE9BQU9FO0FBQzFEO0FBRUEsU0FBU0MsU0FBU04sS0FBSztJQUNyQixPQUFPQSxTQUFTLE9BQU8sS0FBS0ksYUFBYUo7QUFDM0M7QUFFQSxTQUFTTyxTQUFTUCxLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVBLFNBQVNRLFNBQVNSLEtBQUs7SUFDckIsT0FBTyxPQUFPQSxVQUFVO0FBQzFCO0FBRUEsMEVBQTBFO0FBQzFFLFNBQVNTLFVBQVVULEtBQUs7SUFDdEIsT0FDRUEsVUFBVSxRQUNWQSxVQUFVLFNBQ1RVLGFBQWFWLFVBQVVFLE9BQU9GLFVBQVU7QUFFN0M7QUFFQSxTQUFTVyxTQUFTWCxLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVBLG9DQUFvQztBQUNwQyxTQUFTVSxhQUFhVixLQUFLO0lBQ3pCLE9BQU9XLFNBQVNYLFVBQVVBLFVBQVU7QUFDdEM7QUFFQSxTQUFTWSxVQUFVWixLQUFLO0lBQ3RCLE9BQU9BLFVBQVVhLGFBQWFiLFVBQVU7QUFDMUM7QUFFQSxTQUFTYyxRQUFRZCxLQUFLO0lBQ3BCLE9BQU8sQ0FBQ0EsTUFB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Q0FBQ3ZDO1lBRXRELElBQUlzQixTQUFTO2dCQUNYNEIsUUFBUWpLLElBQUksQ0FBQztvQkFBRWtDO29CQUFPbkQ7b0JBQUt2QixPQUFPdUo7b0JBQU1oRTtvQkFBTTJEO2dCQUFRO1lBQ3hEO1FBQ0Y7UUFFQSxPQUFPdUQ7SUFDVDtBQUNGO0FBRUFnRSxLQUFLcUIsT0FBTyxHQUFHO0FBQ2ZyQixLQUFLdEksV0FBVyxHQUFHQTtBQUNuQnNJLEtBQUtuSSxVQUFVLEdBQUdBO0FBQ2xCbUksS0FBS3NCLE1BQU0sR0FBRzFNO0FBRWQ7SUFDRW9MLEtBQUsvQyxVQUFVLEdBQUcrQjtBQUNwQixDQUVBO0lBQ0VkLFNBQVNQO0FBQ1gsQ0FFMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xaW5nc2hpLWNhbG9yaWUtY2FsY3VsYXRvci8uL25vZGVfbW9kdWxlcy8ucG5wbS9mdXNlLmpzQDcuMS4wL25vZGVfbW9kdWxlcy9mdXNlLmpzL2Rpc3QvZnVzZS5tanM/MzAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZ1c2UuanMgdjcuMS4wIC0gTGlnaHR3ZWlnaHQgZnV6enktc2VhcmNoIChodHRwOi8vZnVzZWpzLmlvKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyNSBLaXJvIFJpc2sgKGh0dHA6Ly9raXJvLm1lKVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC4gQXBhY2hlIFNvZnR3YXJlIExpY2Vuc2UgMi4wXG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXlcbiAgICA/IGdldFRhZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsdWUpXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2Jhc2VUb1N0cmluZy5qc1xuY29uc3QgSU5GSU5JVFkgPSAxIC8gMDtcbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZhbHVlICsgJyc7XG4gIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvaXNCb29sZWFuLmpzXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA9PT0gdHJ1ZSB8fFxuICAgIHZhbHVlID09PSBmYWxzZSB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gJ1tvYmplY3QgQm9vbGVhbl0nKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbi8vIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzQmxhbmsodmFsdWUpIHtcbiAgcmV0dXJuICF2YWx1ZS50cmltKCkubGVuZ3RoXG59XG5cbi8vIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2dldFRhZy5qc1xuZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsXG4gICAgPyB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICdbb2JqZWN0IFVuZGVmaW5lZF0nXG4gICAgICA6ICdbb2JqZWN0IE51bGxdJ1xuICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxufVxuXG5jb25zdCBFWFRFTkRFRF9TRUFSQ0hfVU5BVkFJTEFCTEUgPSAnRXh0ZW5kZWQgc2VhcmNoIGlzIG5vdCBhdmFpbGFibGUnO1xuXG5jb25zdCBJTkNPUlJFQ1RfSU5ERVhfVFlQRSA9IFwiSW5jb3JyZWN0ICdpbmRleCcgdHlwZVwiO1xuXG5jb25zdCBMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkgPSAoa2V5KSA9PlxuICBgSW52YWxpZCB2YWx1ZSBmb3Iga2V5ICR7a2V5fWA7XG5cbmNvbnN0IFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRSA9IChtYXgpID0+XG4gIGBQYXR0ZXJuIGxlbmd0aCBleGNlZWRzIG1heCBvZiAke21heH0uYDtcblxuY29uc3QgTUlTU0lOR19LRVlfUFJPUEVSVFkgPSAobmFtZSkgPT4gYE1pc3NpbmcgJHtuYW1lfSBwcm9wZXJ0eSBpbiBrZXlgO1xuXG5jb25zdCBJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUgPSAoa2V5KSA9PlxuICBgUHJvcGVydHkgJ3dlaWdodCcgaW4ga2V5ICcke2tleX0nIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyYDtcblxuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuY2xhc3MgS2V5U3RvcmUge1xuICBjb25zdHJ1Y3RvcihrZXlzKSB7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX2tleU1hcCA9IHt9O1xuXG4gICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBsZXQgb2JqID0gY3JlYXRlS2V5KGtleSk7XG5cbiAgICAgIHRoaXMuX2tleXMucHVzaChvYmopO1xuICAgICAgdGhpcy5fa2V5TWFwW29iai5pZF0gPSBvYmo7XG5cbiAgICAgIHRvdGFsV2VpZ2h0ICs9IG9iai53ZWlnaHQ7XG4gICAgfSk7XG5cbiAgICAvLyBOb3JtYWxpemUgd2VpZ2h0cyBzbyB0aGF0IHRoZWlyIHN1bSBpcyBlcXVhbCB0byAxXG4gICAgdGhpcy5fa2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGtleS53ZWlnaHQgLz0gdG90YWxXZWlnaHQ7XG4gICAgfSk7XG4gIH1cbiAgZ2V0KGtleUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleU1hcFtrZXlJZF1cbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXlzXG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLl9rZXlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgbGV0IHBhdGggPSBudWxsO1xuICBsZXQgaWQgPSBudWxsO1xuICBsZXQgc3JjID0gbnVsbDtcbiAgbGV0IHdlaWdodCA9IDE7XG4gIGxldCBnZXRGbiA9IG51bGw7XG5cbiAgaWYgKGlzU3RyaW5nKGtleSkgfHwgaXNBcnJheShrZXkpKSB7XG4gICAgc3JjID0ga2V5O1xuICAgIHBhdGggPSBjcmVhdGVLZXlQYXRoKGtleSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChrZXkpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaGFzT3duLmNhbGwoa2V5LCAnbmFtZScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTUlTU0lOR19LRVlfUFJPUEVSVFkoJ25hbWUnKSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0ga2V5Lm5hbWU7XG4gICAgc3JjID0gbmFtZTtcblxuICAgIGlmIChoYXNPd24uY2FsbChrZXksICd3ZWlnaHQnKSkge1xuICAgICAgd2VpZ2h0ID0ga2V5LndlaWdodDtcblxuICAgICAgaWYgKHdlaWdodCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUobmFtZSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgobmFtZSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChuYW1lKTtcbiAgICBnZXRGbiA9IGtleS5nZXRGbjtcbiAgfVxuXG4gIHJldHVybiB7IHBhdGgsIGlkLCB3ZWlnaHQsIHNyYywgZ2V0Rm4gfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlQYXRoKGtleSkge1xuICByZXR1cm4gaXNBcnJheShrZXkpID8ga2V5IDoga2V5LnNwbGl0KCcuJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5SWQoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkuam9pbignLicpIDoga2V5XG59XG5cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgbGV0IGxpc3QgPSBbXTtcbiAgbGV0IGFyciA9IGZhbHNlO1xuXG4gIGNvbnN0IGRlZXBHZXQgPSAob2JqLCBwYXRoLCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG9iaikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIXBhdGhbaW5kZXhdKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhdGggbGVmdCwgd2UndmUgYXJyaXZlZCBhdCB0aGUgb2JqZWN0IHdlIGNhcmUgYWJvdXQuXG4gICAgICBsaXN0LnB1c2gob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGtleSA9IHBhdGhbaW5kZXhdO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGF0IHRoZSBsYXN0IHZhbHVlIGluIHRoZSBwYXRoLCBhbmQgaWYgaXQncyBhIHN0cmluZy9udW1iZXIvYm9vbCxcbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgaWYgKFxuICAgICAgICBpbmRleCA9PT0gcGF0aC5sZW5ndGggLSAxICYmXG4gICAgICAgIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNOdW1iZXIodmFsdWUpIHx8IGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgICApIHtcbiAgICAgICAgbGlzdC5wdXNoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGFyciA9IHRydWU7XG4gICAgICAgIC8vIFNlYXJjaCBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBkZWVwR2V0KHZhbHVlW2ldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFuIG9iamVjdC4gUmVjdXJzZSBmdXJ0aGVyLlxuICAgICAgICBkZWVwR2V0KHZhbHVlLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoc2luY2UgcGF0aCB1c2VkIHRvIGJlIGEgc3RyaW5nKVxuICBkZWVwR2V0KG9iaiwgaXNTdHJpbmcocGF0aCkgPyBwYXRoLnNwbGl0KCcuJykgOiBwYXRoLCAwKTtcblxuICByZXR1cm4gYXJyID8gbGlzdCA6IGxpc3RbMF1cbn1cblxuY29uc3QgTWF0Y2hPcHRpb25zID0ge1xuICAvLyBXaGV0aGVyIHRoZSBtYXRjaGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldC4gV2hlbiBgdHJ1ZWAsIGVhY2ggcmVjb3JkIGluIHRoZSByZXN1bHRcbiAgLy8gc2V0IHdpbGwgaW5jbHVkZSB0aGUgaW5kaWNlcyBvZiB0aGUgbWF0Y2hlZCBjaGFyYWN0ZXJzLlxuICAvLyBUaGVzZSBjYW4gY29uc2VxdWVudGx5IGJlIHVzZWQgZm9yIGhpZ2hsaWdodGluZyBwdXJwb3Nlcy5cbiAgaW5jbHVkZU1hdGNoZXM6IGZhbHNlLFxuICAvLyBXaGVuIGB0cnVlYCwgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHdpbGwgY29udGludWUgdG8gdGhlIGVuZCBvZiBhIHNlYXJjaCBwYXR0ZXJuIGV2ZW4gaWZcbiAgLy8gYSBwZXJmZWN0IG1hdGNoIGhhcyBhbHJlYWR5IGJlZW4gbG9jYXRlZCBpbiB0aGUgc3RyaW5nLlxuICBmaW5kQWxsTWF0Y2hlczogZmFsc2UsXG4gIC8vIE1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIG1hdGNoZWQgYmVmb3JlIGEgcmVzdWx0IGlzIGNvbnNpZGVyZWQgYSBtYXRjaFxuICBtaW5NYXRjaENoYXJMZW5ndGg6IDFcbn07XG5cbmNvbnN0IEJhc2ljT3B0aW9ucyA9IHtcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBhbGdvcml0aG0gY29udGludWVzIHNlYXJjaGluZyB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dCBldmVuIGlmIGEgcGVyZmVjdFxuICAvLyBtYXRjaCBpcyBmb3VuZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgc2FtZSBpbnB1dC5cbiAgaXNDYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBhbGdvcml0aG0gd2lsbCBpZ25vcmUgZGlhY3JpdGljcyAoYWNjZW50cykgaW4gY29tcGFyaXNvbnNcbiAgaWdub3JlRGlhY3JpdGljczogZmFsc2UsXG4gIC8vIFdoZW4gdHJ1ZSwgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHdpbGwgY29udGludWUgdG8gdGhlIGVuZCBvZiBhIHNlYXJjaCBwYXR0ZXJuIGV2ZW4gaWZcbiAgaW5jbHVkZVNjb3JlOiBmYWxzZSxcbiAgLy8gTGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBzZWFyY2hlZC4gVGhpcyBhbHNvIHN1cHBvcnRzIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICBrZXlzOiBbXSxcbiAgLy8gV2hldGhlciB0byBzb3J0IHRoZSByZXN1bHQgbGlzdCwgYnkgc2NvcmVcbiAgc2hvdWxkU29ydDogdHJ1ZSxcbiAgLy8gRGVmYXVsdCBzb3J0IGZ1bmN0aW9uOiBzb3J0IGJ5IGFzY2VuZGluZyBzY29yZSwgYXNjZW5kaW5nIGluZGV4XG4gIHNvcnRGbjogKGEsIGIpID0+XG4gICAgYS5zY29yZSA9PT0gYi5zY29yZSA/IChhLmlkeCA8IGIuaWR4ID8gLTEgOiAxKSA6IGEuc2NvcmUgPCBiLnNjb3JlID8gLTEgOiAxXG59O1xuXG5jb25zdCBGdXp6eU9wdGlvbnMgPSB7XG4gIC8vIEFwcHJveGltYXRlbHkgd2hlcmUgaW4gdGhlIHRleHQgaXMgdGhlIHBhdHRlcm4gZXhwZWN0ZWQgdG8gYmUgZm91bmQ/XG4gIGxvY2F0aW9uOiAwLFxuICAvLyBBdCB3aGF0IHBvaW50IGRvZXMgdGhlIG1hdGNoIGFsZ29yaXRobSBnaXZlIHVwLiBBIHRocmVzaG9sZCBvZiAnMC4wJyByZXF1aXJlcyBhIHBlcmZlY3QgbWF0Y2hcbiAgLy8gKG9mIGJvdGggbGV0dGVycyBhbmQgbG9jYXRpb24pLCBhIHRocmVzaG9sZCBvZiAnMS4wJyB3b3VsZCBtYXRjaCBhbnl0aGluZy5cbiAgdGhyZXNob2xkOiAwLjYsXG4gIC8vIERldGVybWluZXMgaG93IGNsb3NlIHRoZSBtYXRjaCBtdXN0IGJlIHRvIHRoZSBmdXp6eSBsb2NhdGlvbiAoc3BlY2lmaWVkIGFib3ZlKS5cbiAgLy8gQW4gZXhhY3QgbGV0dGVyIG1hdGNoIHdoaWNoIGlzICdkaXN0YW5jZScgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGZ1enp5IGxvY2F0aW9uXG4gIC8vIHdvdWxkIHNjb3JlIGFzIGEgY29tcGxldGUgbWlzbWF0Y2guIEEgZGlzdGFuY2Ugb2YgJzAnIHJlcXVpcmVzIHRoZSBtYXRjaCBiZSBhdFxuICAvLyB0aGUgZXhhY3QgbG9jYXRpb24gc3BlY2lmaWVkLCBhIHRocmVzaG9sZCBvZiAnMTAwMCcgd291bGQgcmVxdWlyZSBhIHBlcmZlY3QgbWF0Y2hcbiAgLy8gdG8gYmUgd2l0aGluIDgwMCBjaGFyYWN0ZXJzIG9mIHRoZSBmdXp6eSBsb2NhdGlvbiB0byBiZSBmb3VuZCB1c2luZyBhIDAuOCB0aHJlc2hvbGQuXG4gIGRpc3RhbmNlOiAxMDBcbn07XG5cbmNvbnN0IEFkdmFuY2VkT3B0aW9ucyA9IHtcbiAgLy8gV2hlbiBgdHJ1ZWAsIGl0IGVuYWJsZXMgdGhlIHVzZSBvZiB1bml4LWxpa2Ugc2VhcmNoIGNvbW1hbmRzXG4gIHVzZUV4dGVuZGVkU2VhcmNoOiBmYWxzZSxcbiAgLy8gVGhlIGdldCBmdW5jdGlvbiB0byB1c2Ugd2hlbiBmZXRjaGluZyBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBUaGUgZGVmYXVsdCB3aWxsIHNlYXJjaCBuZXN0ZWQgcGF0aHMgKmllIGZvby5iYXIuYmF6KlxuICBnZXRGbjogZ2V0LFxuICAvLyBXaGVuIGB0cnVlYCwgc2VhcmNoIHdpbGwgaWdub3JlIGBsb2NhdGlvbmAgYW5kIGBkaXN0YW5jZWAsIHNvIGl0IHdvbid0IG1hdHRlclxuICAvLyB3aGVyZSBpbiB0aGUgc3RyaW5nIHRoZSBwYXR0ZXJuIGFwcGVhcnMuXG4gIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9mdXNlanMuaW8vY29uY2VwdHMvc2NvcmluZy10aGVvcnkuaHRtbCNmdXp6aW5lc3Mtc2NvcmVcbiAgaWdub3JlTG9jYXRpb246IGZhbHNlLFxuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGNhbGN1bGF0aW9uIGZvciB0aGUgcmVsZXZhbmNlIHNjb3JlICh1c2VkIGZvciBzb3J0aW5nKSB3aWxsXG4gIC8vIGlnbm9yZSB0aGUgZmllbGQtbGVuZ3RoIG5vcm0uXG4gIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9mdXNlanMuaW8vY29uY2VwdHMvc2NvcmluZy10aGVvcnkuaHRtbCNmaWVsZC1sZW5ndGgtbm9ybVxuICBpZ25vcmVGaWVsZE5vcm06IGZhbHNlLFxuICAvLyBUaGUgd2VpZ2h0IHRvIGRldGVybWluZSBob3cgbXVjaCBmaWVsZCBsZW5ndGggbm9ybSBlZmZlY3RzIHNjb3JpbmcuXG4gIGZpZWxkTm9ybVdlaWdodDogMVxufTtcblxudmFyIENvbmZpZyA9IHtcbiAgLi4uQmFzaWNPcHRpb25zLFxuICAuLi5NYXRjaE9wdGlvbnMsXG4gIC4uLkZ1enp5T3B0aW9ucyxcbiAgLi4uQWR2YW5jZWRPcHRpb25zXG59O1xuXG5jb25zdCBTUEFDRSA9IC9bXiBdKy9nO1xuXG4vLyBGaWVsZC1sZW5ndGggbm9ybTogdGhlIHNob3J0ZXIgdGhlIGZpZWxkLCB0aGUgaGlnaGVyIHRoZSB3ZWlnaHQuXG4vLyBTZXQgdG8gMyBkZWNpbWFscyB0byByZWR1Y2UgaW5kZXggc2l6ZS5cbmZ1bmN0aW9uIG5vcm0od2VpZ2h0ID0gMSwgbWFudGlzc2EgPSAzKSB7XG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtID0gTWF0aC5wb3coMTAsIG1hbnRpc3NhKTtcblxuICByZXR1cm4ge1xuICAgIGdldCh2YWx1ZSkge1xuICAgICAgY29uc3QgbnVtVG9rZW5zID0gdmFsdWUubWF0Y2goU1BBQ0UpLmxlbmd0aDtcblxuICAgICAgaWYgKGNhY2hlLmhhcyhudW1Ub2tlbnMpKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQobnVtVG9rZW5zKVxuICAgICAgfVxuXG4gICAgICAvLyBEZWZhdWx0IGZ1bmN0aW9uIGlzIDEvc3FydCh4KSwgd2VpZ2h0IG1ha2VzIHRoYXQgdmFyaWFibGVcbiAgICAgIGNvbnN0IG5vcm0gPSAxIC8gTWF0aC5wb3cobnVtVG9rZW5zLCAwLjUgKiB3ZWlnaHQpO1xuXG4gICAgICAvLyBJbiBwbGFjZSBvZiBgdG9GaXhlZChtYW50aXNzYSlgLCBmb3IgZmFzdGVyIGNvbXB1dGF0aW9uXG4gICAgICBjb25zdCBuID0gcGFyc2VGbG9hdChNYXRoLnJvdW5kKG5vcm0gKiBtKSAvIG0pO1xuXG4gICAgICBjYWNoZS5zZXQobnVtVG9rZW5zLCBuKTtcblxuICAgICAgcmV0dXJuIG5cbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRnVzZUluZGV4IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGdldEZuID0gQ29uZmlnLmdldEZuLFxuICAgIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5ub3JtID0gbm9ybShmaWVsZE5vcm1XZWlnaHQsIDMpO1xuICAgIHRoaXMuZ2V0Rm4gPSBnZXRGbjtcbiAgICB0aGlzLmlzQ3JlYXRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRJbmRleFJlY29yZHMoKTtcbiAgfVxuICBzZXRTb3VyY2VzKGRvY3MgPSBbXSkge1xuICAgIHRoaXMuZG9jcyA9IGRvY3M7XG4gIH1cbiAgc2V0SW5kZXhSZWNvcmRzKHJlY29yZHMgPSBbXSkge1xuICAgIHRoaXMucmVjb3JkcyA9IHJlY29yZHM7XG4gIH1cbiAgc2V0S2V5cyhrZXlzID0gW10pIHtcbiAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgIHRoaXMuX2tleXNNYXAgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSwgaWR4KSA9PiB7XG4gICAgICB0aGlzLl9rZXlzTWFwW2tleS5pZF0gPSBpZHg7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlKCkge1xuICAgIGlmICh0aGlzLmlzQ3JlYXRlZCB8fCAhdGhpcy5kb2NzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5pc0NyZWF0ZWQgPSB0cnVlO1xuXG4gICAgLy8gTGlzdCBpcyBBcnJheTxTdHJpbmc+XG4gICAgaWYgKGlzU3RyaW5nKHRoaXMuZG9jc1swXSkpIHtcbiAgICAgIHRoaXMuZG9jcy5mb3JFYWNoKChkb2MsIGRvY0luZGV4KSA9PiB7XG4gICAgICAgIHRoaXMuX2FkZFN0cmluZyhkb2MsIGRvY0luZGV4KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0IGlzIEFycmF5PE9iamVjdD5cbiAgICAgIHRoaXMuZG9jcy5mb3JFYWNoKChkb2MsIGRvY0luZGV4KSA9PiB7XG4gICAgICAgIHRoaXMuX2FkZE9iamVjdChkb2MsIGRvY0luZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubm9ybS5jbGVhcigpO1xuICB9XG4gIC8vIEFkZHMgYSBkb2MgdG8gdGhlIGVuZCBvZiB0aGUgaW5kZXhcbiAgYWRkKGRvYykge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuc2l6ZSgpO1xuXG4gICAgaWYgKGlzU3RyaW5nKGRvYykpIHtcbiAgICAgIHRoaXMuX2FkZFN0cmluZyhkb2MsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZE9iamVjdChkb2MsIGlkeCk7XG4gICAgfVxuICB9XG4gIC8vIFJlbW92ZXMgdGhlIGRvYyBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9mIHRoZSBpbmRleFxuICByZW1vdmVBdChpZHgpIHtcbiAgICB0aGlzLnJlY29yZHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAvLyBDaGFuZ2UgcmVmIGluZGV4IG9mIGV2ZXJ5IHN1YnNxdWVudCBkb2NcbiAgICBmb3IgKGxldCBpID0gaWR4LCBsZW4gPSB0aGlzLnNpemUoKTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnJlY29yZHNbaV0uaSAtPSAxO1xuICAgIH1cbiAgfVxuICBnZXRWYWx1ZUZvckl0ZW1BdEtleUlkKGl0ZW0sIGtleUlkKSB7XG4gICAgcmV0dXJuIGl0ZW1bdGhpcy5fa2V5c01hcFtrZXlJZF1dXG4gIH1cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvcmRzLmxlbmd0aFxuICB9XG4gIF9hZGRTdHJpbmcoZG9jLCBkb2NJbmRleCkge1xuICAgIGlmICghaXNEZWZpbmVkKGRvYykgfHwgaXNCbGFuayhkb2MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgcmVjb3JkID0ge1xuICAgICAgdjogZG9jLFxuICAgICAgaTogZG9jSW5kZXgsXG4gICAgICBuOiB0aGlzLm5vcm0uZ2V0KGRvYylcbiAgICB9O1xuXG4gICAgdGhpcy5yZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuICBfYWRkT2JqZWN0KGRvYywgZG9jSW5kZXgpIHtcbiAgICBsZXQgcmVjb3JkID0geyBpOiBkb2NJbmRleCwgJDoge30gfTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBrZXkgKGkuZSwgcGF0aCksIGFuZCBmZXRjaCB0aGUgdmFsdWUgYXQgdGhhdCBrZXlcbiAgICB0aGlzLmtleXMuZm9yRWFjaCgoa2V5LCBrZXlJbmRleCkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0ga2V5LmdldEZuID8ga2V5LmdldEZuKGRvYykgOiB0aGlzLmdldEZuKGRvYywga2V5LnBhdGgpO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBsZXQgc3ViUmVjb3JkcyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFjayA9IFt7IG5lc3RlZEFyckluZGV4OiAtMSwgdmFsdWUgfV07XG5cbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHsgbmVzdGVkQXJySW5kZXgsIHZhbHVlIH0gPSBzdGFjay5wb3AoKTtcblxuICAgICAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICAgICAgdjogdmFsdWUsXG4gICAgICAgICAgICAgIGk6IG5lc3RlZEFyckluZGV4LFxuICAgICAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3ViUmVjb3Jkcy5wdXNoKHN1YlJlY29yZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaykgPT4ge1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRBcnJJbmRleDogayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSA7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3JkLiRba2V5SW5kZXhdID0gc3ViUmVjb3JkcztcbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICBsZXQgc3ViUmVjb3JkID0ge1xuICAgICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAgIG46IHRoaXMubm9ybS5nZXQodmFsdWUpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVjb3JkLiRba2V5SW5kZXhdID0gc3ViUmVjb3JkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IHRoaXMua2V5cyxcbiAgICAgIHJlY29yZHM6IHRoaXMucmVjb3Jkc1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmRleChcbiAga2V5cyxcbiAgZG9jcyxcbiAgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiwgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodCB9ID0ge31cbikge1xuICBjb25zdCBteUluZGV4ID0gbmV3IEZ1c2VJbmRleCh7IGdldEZuLCBmaWVsZE5vcm1XZWlnaHQgfSk7XG4gIG15SW5kZXguc2V0S2V5cyhrZXlzLm1hcChjcmVhdGVLZXkpKTtcbiAgbXlJbmRleC5zZXRTb3VyY2VzKGRvY3MpO1xuICBteUluZGV4LmNyZWF0ZSgpO1xuICByZXR1cm4gbXlJbmRleFxufVxuXG5mdW5jdGlvbiBwYXJzZUluZGV4KFxuICBkYXRhLFxuICB7IGdldEZuID0gQ29uZmlnLmdldEZuLCBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0IH0gPSB7fVxuKSB7XG4gIGNvbnN0IHsga2V5cywgcmVjb3JkcyB9ID0gZGF0YTtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiwgZmllbGROb3JtV2VpZ2h0IH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cyk7XG4gIG15SW5kZXguc2V0SW5kZXhSZWNvcmRzKHJlY29yZHMpO1xuICByZXR1cm4gbXlJbmRleFxufVxuXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUkMShcbiAgcGF0dGVybixcbiAge1xuICAgIGVycm9ycyA9IDAsXG4gICAgY3VycmVudExvY2F0aW9uID0gMCxcbiAgICBleHBlY3RlZExvY2F0aW9uID0gMCxcbiAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICB9ID0ge31cbikge1xuICBjb25zdCBhY2N1cmFjeSA9IGVycm9ycyAvIHBhdHRlcm4ubGVuZ3RoO1xuXG4gIGlmIChpZ25vcmVMb2NhdGlvbikge1xuICAgIHJldHVybiBhY2N1cmFjeVxuICB9XG5cbiAgY29uc3QgcHJveGltaXR5ID0gTWF0aC5hYnMoZXhwZWN0ZWRMb2NhdGlvbiAtIGN1cnJlbnRMb2NhdGlvbik7XG5cbiAgaWYgKCFkaXN0YW5jZSkge1xuICAgIC8vIERvZGdlIGRpdmlkZSBieSB6ZXJvIGVycm9yLlxuICAgIHJldHVybiBwcm94aW1pdHkgPyAxLjAgOiBhY2N1cmFjeVxuICB9XG5cbiAgcmV0dXJuIGFjY3VyYWN5ICsgcHJveGltaXR5IC8gZGlzdGFuY2Vcbn1cblxuZnVuY3Rpb24gY29udmVydE1hc2tUb0luZGljZXMoXG4gIG1hdGNobWFzayA9IFtdLFxuICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoXG4pIHtcbiAgbGV0IGluZGljZXMgPSBbXTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAobGV0IGxlbiA9IG1hdGNobWFzay5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBtYXRjaCA9IG1hdGNobWFza1tpXTtcbiAgICBpZiAobWF0Y2ggJiYgc3RhcnQgPT09IC0xKSB7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2ggJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICBlbmQgPSBpIC0gMTtcbiAgICAgIGlmIChlbmQgLSBzdGFydCArIDEgPj0gbWluTWF0Y2hDaGFyTGVuZ3RoKSB7XG4gICAgICAgIGluZGljZXMucHVzaChbc3RhcnQsIGVuZF0pO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAtMTtcbiAgICB9XG4gIH1cblxuICAvLyAoaS0xIC0gc3RhcnQpICsgMSA9PiBpIC0gc3RhcnRcbiAgaWYgKG1hdGNobWFza1tpIC0gMV0gJiYgaSAtIHN0YXJ0ID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgIGluZGljZXMucHVzaChbc3RhcnQsIGkgLSAxXSk7XG4gIH1cblxuICByZXR1cm4gaW5kaWNlc1xufVxuXG4vLyBNYWNoaW5lIHdvcmQgc2l6ZVxuY29uc3QgTUFYX0JJVFMgPSAzMjtcblxuZnVuY3Rpb24gc2VhcmNoKFxuICB0ZXh0LFxuICBwYXR0ZXJuLFxuICBwYXR0ZXJuQWxwaGFiZXQsXG4gIHtcbiAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0JJVFMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFKE1BWF9CSVRTKSlcbiAgfVxuXG4gIGNvbnN0IHBhdHRlcm5MZW4gPSBwYXR0ZXJuLmxlbmd0aDtcbiAgLy8gU2V0IHN0YXJ0aW5nIGxvY2F0aW9uIGF0IGJlZ2lubmluZyB0ZXh0IGFuZCBpbml0aWFsaXplIHRoZSBhbHBoYWJldC5cbiAgY29uc3QgdGV4dExlbiA9IHRleHQubGVuZ3RoO1xuICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlbiBsb2NhdGlvbiA+IHRleHQubGVuZ3RoXG4gIGNvbnN0IGV4cGVjdGVkTG9jYXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsb2NhdGlvbiwgdGV4dExlbikpO1xuICAvLyBIaWdoZXN0IHNjb3JlIGJleW9uZCB3aGljaCB3ZSBnaXZlIHVwLlxuICBsZXQgY3VycmVudFRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgLy8gSXMgdGhlcmUgYSBuZWFyYnkgZXhhY3QgbWF0Y2g/IChzcGVlZHVwKVxuICBsZXQgYmVzdExvY2F0aW9uID0gZXhwZWN0ZWRMb2NhdGlvbjtcblxuICAvLyBQZXJmb3JtYW5jZTogb25seSBjb21wdXRlciBtYXRjaGVzIHdoZW4gdGhlIG1pbk1hdGNoQ2hhckxlbmd0aCA+IDFcbiAgLy8gT1IgaWYgYGluY2x1ZGVNYXRjaGVzYCBpcyB0cnVlLlxuICBjb25zdCBjb21wdXRlTWF0Y2hlcyA9IG1pbk1hdGNoQ2hhckxlbmd0aCA+IDEgfHwgaW5jbHVkZU1hdGNoZXM7XG4gIC8vIEEgbWFzayBvZiB0aGUgbWF0Y2hlcywgdXNlZCBmb3IgYnVpbGRpbmcgdGhlIGluZGljZXNcbiAgY29uc3QgbWF0Y2hNYXNrID0gY29tcHV0ZU1hdGNoZXMgPyBBcnJheSh0ZXh0TGVuKSA6IFtdO1xuXG4gIGxldCBpbmRleDtcblxuICAvLyBHZXQgYWxsIGV4YWN0IG1hdGNoZXMsIGhlcmUgZm9yIHNwZWVkIHVwXG4gIHdoaWxlICgoaW5kZXggPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgYmVzdExvY2F0aW9uKSkgPiAtMSkge1xuICAgIGxldCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW5kZXgsXG4gICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuXG4gICAgY3VycmVudFRocmVzaG9sZCA9IE1hdGgubWluKHNjb3JlLCBjdXJyZW50VGhyZXNob2xkKTtcbiAgICBiZXN0TG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG5cbiAgICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgcGF0dGVybkxlbikge1xuICAgICAgICBtYXRjaE1hc2tbaW5kZXggKyBpXSA9IDE7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXNldCB0aGUgYmVzdCBsb2NhdGlvblxuICBiZXN0TG9jYXRpb24gPSAtMTtcblxuICBsZXQgbGFzdEJpdEFyciA9IFtdO1xuICBsZXQgZmluYWxTY29yZSA9IDE7XG4gIGxldCBiaW5NYXggPSBwYXR0ZXJuTGVuICsgdGV4dExlbjtcblxuICBjb25zdCBtYXNrID0gMSA8PCAocGF0dGVybkxlbiAtIDEpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSArPSAxKSB7XG4gICAgLy8gU2NhbiBmb3IgdGhlIGJlc3QgbWF0Y2g7IGVhY2ggaXRlcmF0aW9uIGFsbG93cyBmb3Igb25lIG1vcmUgZXJyb3IuXG4gICAgLy8gUnVuIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgaG93IGZhciBmcm9tIHRoZSBtYXRjaCBsb2NhdGlvbiB3ZSBjYW4gc3RyYXlcbiAgICAvLyBhdCB0aGlzIGVycm9yIGxldmVsLlxuICAgIGxldCBiaW5NaW4gPSAwO1xuICAgIGxldCBiaW5NaWQgPSBiaW5NYXg7XG5cbiAgICB3aGlsZSAoYmluTWluIDwgYmluTWlkKSB7XG4gICAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24gKyBiaW5NaWQsXG4gICAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzY29yZSA8PSBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICAgIGJpbk1pbiA9IGJpbk1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbk1heCA9IGJpbk1pZDtcbiAgICAgIH1cblxuICAgICAgYmluTWlkID0gTWF0aC5mbG9vcigoYmluTWF4IC0gYmluTWluKSAvIDIgKyBiaW5NaW4pO1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgcmVzdWx0IGZyb20gdGhpcyBpdGVyYXRpb24gYXMgdGhlIG1heGltdW0gZm9yIHRoZSBuZXh0LlxuICAgIGJpbk1heCA9IGJpbk1pZDtcblxuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGV4cGVjdGVkTG9jYXRpb24gLSBiaW5NaWQgKyAxKTtcbiAgICBsZXQgZmluaXNoID0gZmluZEFsbE1hdGNoZXNcbiAgICAgID8gdGV4dExlblxuICAgICAgOiBNYXRoLm1pbihleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLCB0ZXh0TGVuKSArIHBhdHRlcm5MZW47XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBiaXQgYXJyYXlcbiAgICBsZXQgYml0QXJyID0gQXJyYXkoZmluaXNoICsgMik7XG5cbiAgICBiaXRBcnJbZmluaXNoICsgMV0gPSAoMSA8PCBpKSAtIDE7XG5cbiAgICBmb3IgKGxldCBqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqIC09IDEpIHtcbiAgICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBqIC0gMTtcbiAgICAgIGxldCBjaGFyTWF0Y2ggPSBwYXR0ZXJuQWxwaGFiZXRbdGV4dC5jaGFyQXQoY3VycmVudExvY2F0aW9uKV07XG5cbiAgICAgIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgICAgICAvLyBTcGVlZCB1cDogcXVpY2sgYm9vbCB0byBpbnQgY29udmVyc2lvbiAoaS5lLCBgY2hhck1hdGNoID8gMSA6IDBgKVxuICAgICAgICBtYXRjaE1hc2tbY3VycmVudExvY2F0aW9uXSA9ICshIWNoYXJNYXRjaDtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2hcbiAgICAgIGJpdEFycltqXSA9ICgoYml0QXJyW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoO1xuXG4gICAgICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2hcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGJpdEFycltqXSB8PVxuICAgICAgICAgICgobGFzdEJpdEFycltqICsgMV0gfCBsYXN0Qml0QXJyW2pdKSA8PCAxKSB8IDEgfCBsYXN0Qml0QXJyW2ogKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpdEFycltqXSAmIG1hc2spIHtcbiAgICAgICAgZmluYWxTY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgICAgICBlcnJvcnM6IGksXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGhpcyBtYXRjaCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYmUgYmV0dGVyIHRoYW4gYW55IGV4aXN0aW5nIG1hdGNoLlxuICAgICAgICAvLyBCdXQgY2hlY2sgYW55d2F5LlxuICAgICAgICBpZiAoZmluYWxTY29yZSA8PSBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gSW5kZWVkIGl0IGlzXG4gICAgICAgICAgY3VycmVudFRocmVzaG9sZCA9IGZpbmFsU2NvcmU7XG4gICAgICAgICAgYmVzdExvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xuXG4gICAgICAgICAgLy8gQWxyZWFkeSBwYXNzZWQgYGxvY2AsIGRvd25oaWxsIGZyb20gaGVyZSBvbiBpbi5cbiAgICAgICAgICBpZiAoYmVzdExvY2F0aW9uIDw9IGV4cGVjdGVkTG9jYXRpb24pIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGBiZXN0TG9jYXRpb25gLCBkb24ndCBleGNlZWQgb3VyIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSBgZXhwZWN0ZWRMb2NhdGlvbmAuXG4gICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogZXhwZWN0ZWRMb2NhdGlvbiAtIGJlc3RMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBob3BlIGZvciBhIChiZXR0ZXIpIG1hdGNoIGF0IGdyZWF0ZXIgZXJyb3IgbGV2ZWxzLlxuICAgIGNvbnN0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgZXJyb3JzOiBpICsgMSxcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAoc2NvcmUgPiBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGxhc3RCaXRBcnIgPSBiaXRBcnI7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaXNNYXRjaDogYmVzdExvY2F0aW9uID49IDAsXG4gICAgLy8gQ291bnQgZXhhY3QgbWF0Y2hlcyAodGhvc2Ugd2l0aCBhIHNjb3JlIG9mIDApIHRvIGJlIFwiYWxtb3N0XCIgZXhhY3RcbiAgICBzY29yZTogTWF0aC5tYXgoMC4wMDEsIGZpbmFsU2NvcmUpXG4gIH07XG5cbiAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IGNvbnZlcnRNYXNrVG9JbmRpY2VzKG1hdGNoTWFzaywgbWluTWF0Y2hDaGFyTGVuZ3RoKTtcbiAgICBpZiAoIWluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQuaXNNYXRjaCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgIHJlc3VsdC5pbmRpY2VzID0gaW5kaWNlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm5BbHBoYWJldChwYXR0ZXJuKSB7XG4gIGxldCBtYXNrID0ge307XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaGFyID0gcGF0dGVybi5jaGFyQXQoaSk7XG4gICAgbWFza1tjaGFyXSA9IChtYXNrW2NoYXJdIHx8IDApIHwgKDEgPDwgKGxlbiAtIGkgLSAxKSk7XG4gIH1cblxuICByZXR1cm4gbWFza1xufVxuXG5jb25zdCBzdHJpcERpYWNyaXRpY3MgPSBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVxuICAgID8gKChzdHIpID0+IHN0ci5ub3JtYWxpemUoJ05GRCcpLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RDMtXFx1MDhFMVxcdTA4RTMtXFx1MDkwM1xcdTA5M0EtXFx1MDkzQ1xcdTA5M0UtXFx1MDk0RlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MS1cXHUwOTgzXFx1MDlCQ1xcdTA5QkUtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDEtXFx1MEEwM1xcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQUJDXFx1MEFCRS1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxLVxcdTBCMDNcXHUwQjNDXFx1MEIzRS1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDdcXHUwQzAwLVxcdTBDMDRcXHUwQzNFLVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MS1cXHUwQzgzXFx1MENCQ1xcdTBDQkUtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwLVxcdTBEMDNcXHUwRDNCXFx1MEQzQ1xcdTBEM0UtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODJcXHUwRDgzXFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREYyXFx1MERGM1xcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUI5XFx1MEVCQlxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0VcXHUwRjNGXFx1MEY3MS1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyQi1cXHUxMDNFXFx1MTA1Ni1cXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhEXFx1MTA4RlxcdTEwOUEtXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MUExNy1cXHUxQTFCXFx1MUE1NS1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFCRVxcdTFCMDAtXFx1MUIwNFxcdTFCMzQtXFx1MUI0NFxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUI4MlxcdTFCQTEtXFx1MUJBRFxcdTFCRTYtXFx1MUJGM1xcdTFDMjQtXFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFOFxcdTFDRURcXHUxQ0YyLVxcdTFDRjRcXHUxQ0Y3LVxcdTFDRjlcXHUxREMwLVxcdTFERjlcXHUxREZCLVxcdTFERkZcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyMy1cXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUzXFx1QTk4MC1cXHVBOTgzXFx1QTlCMy1cXHVBOUMwXFx1QTlFNVxcdUFBMjktXFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE0RFxcdUFBN0ItXFx1QUE3RFxcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUItXFx1QUFFRlxcdUFBRjVcXHVBQUY2XFx1QUJFMy1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXS9nLCAnJykpXG4gICAgOiAoKHN0cikgPT4gc3RyKTtcblxuY2xhc3MgQml0YXBTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlRGlhY3JpdGljcyA9IENvbmZpZy5pZ25vcmVEaWFjcml0aWNzLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVEaWFjcml0aWNzLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9O1xuXG4gICAgcGF0dGVybiA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgcGF0dGVybiA9IGlnbm9yZURpYWNyaXRpY3MgPyBzdHJpcERpYWNyaXRpY3MocGF0dGVybikgOiBwYXR0ZXJuO1xuICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG5cbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLnBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhZGRDaHVuayA9IChwYXR0ZXJuLCBzdGFydEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgYWxwaGFiZXQ6IGNyZWF0ZVBhdHRlcm5BbHBoYWJldChwYXR0ZXJuKSxcbiAgICAgICAgc3RhcnRJbmRleFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxlbiA9IHRoaXMucGF0dGVybi5sZW5ndGg7XG5cbiAgICBpZiAobGVuID4gTUFYX0JJVFMpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGNvbnN0IHJlbWFpbmRlciA9IGxlbiAlIE1BWF9CSVRTO1xuICAgICAgY29uc3QgZW5kID0gbGVuIC0gcmVtYWluZGVyO1xuXG4gICAgICB3aGlsZSAoaSA8IGVuZCkge1xuICAgICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4uc3Vic3RyKGksIE1BWF9CSVRTKSwgaSk7XG4gICAgICAgIGkgKz0gTUFYX0JJVFM7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1haW5kZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IGxlbiAtIE1BWF9CSVRTO1xuICAgICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4uc3Vic3RyKHN0YXJ0SW5kZXgpLCBzdGFydEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLCAwKTtcbiAgICB9XG4gIH1cblxuICBzZWFyY2hJbih0ZXh0KSB7XG4gICAgY29uc3QgeyBpc0Nhc2VTZW5zaXRpdmUsIGlnbm9yZURpYWNyaXRpY3MsIGluY2x1ZGVNYXRjaGVzIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0ZXh0ID0gaXNDYXNlU2Vuc2l0aXZlID8gdGV4dCA6IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICB0ZXh0ID0gaWdub3JlRGlhY3JpdGljcyA/IHN0cmlwRGlhY3JpdGljcyh0ZXh0KSA6IHRleHQ7XG5cbiAgICAvLyBFeGFjdCBtYXRjaFxuICAgIGlmICh0aGlzLnBhdHRlcm4gPT09IHRleHQpIHtcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGlzTWF0Y2g6IHRydWUsXG4gICAgICAgIHNjb3JlOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgcmVzdWx0LmluZGljZXMgPSBbWzAsIHRleHQubGVuZ3RoIC0gMV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCB1c2UgQml0YXAgYWxnb3JpdGhtXG4gICAgY29uc3Qge1xuICAgICAgbG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgbGV0IGFsbEluZGljZXMgPSBbXTtcbiAgICBsZXQgdG90YWxTY29yZSA9IDA7XG4gICAgbGV0IGhhc01hdGNoZXMgPSBmYWxzZTtcblxuICAgIHRoaXMuY2h1bmtzLmZvckVhY2goKHsgcGF0dGVybiwgYWxwaGFiZXQsIHN0YXJ0SW5kZXggfSkgPT4ge1xuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoKHRleHQsIHBhdHRlcm4sIGFscGhhYmV0LCB7XG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbiArIHN0YXJ0SW5kZXgsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIGhhc01hdGNoZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0b3RhbFNjb3JlICs9IHNjb3JlO1xuXG4gICAgICBpZiAoaXNNYXRjaCAmJiBpbmRpY2VzKSB7XG4gICAgICAgIGFsbEluZGljZXMgPSBbLi4uYWxsSW5kaWNlcywgLi4uaW5kaWNlc107XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgaXNNYXRjaDogaGFzTWF0Y2hlcyxcbiAgICAgIHNjb3JlOiBoYXNNYXRjaGVzID8gdG90YWxTY29yZSAvIHRoaXMuY2h1bmtzLmxlbmd0aCA6IDFcbiAgICB9O1xuXG4gICAgaWYgKGhhc01hdGNoZXMgJiYgaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuY2xhc3MgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gIH1cbiAgc3RhdGljIGlzTXVsdGlNYXRjaChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGdldE1hdGNoKHBhdHRlcm4sIHRoaXMubXVsdGlSZWdleClcbiAgfVxuICBzdGF0aWMgaXNTaW5nbGVNYXRjaChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGdldE1hdGNoKHBhdHRlcm4sIHRoaXMuc2luZ2xlUmVnZXgpXG4gIH1cbiAgc2VhcmNoKC8qdGV4dCovKSB7fVxufVxuXG5mdW5jdGlvbiBnZXRNYXRjaChwYXR0ZXJuLCBleHApIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHBhdHRlcm4ubWF0Y2goZXhwKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogbnVsbFxufVxuXG4vLyBUb2tlbjogJ2ZpbGVcblxuY2xhc3MgRXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdleGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9ePVwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXj0oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0ZXh0ID09PSB0aGlzLnBhdHRlcm47XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhZmlyZVxuXG5jbGFzcyBJbnZlcnNlRXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eISguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0ZXh0LmluZGV4T2YodGhpcy5wYXR0ZXJuKTtcbiAgICBjb25zdCBpc01hdGNoID0gaW5kZXggPT09IC0xO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46IF5maWxlXG5cbmNsYXNzIFByZWZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAncHJlZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cXF5cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL15cXF4oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0ZXh0LnN0YXJ0c1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICFeZmlyZVxuXG5jbGFzcyBJbnZlcnNlUHJlZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLXByZWZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVxcXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcXF4oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSAhdGV4dC5zdGFydHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogLmZpbGUkXG5cbmNsYXNzIFN1ZmZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnc3VmZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIlxcJCQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopXFwkJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0ZXh0LmVuZHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbdGV4dC5sZW5ndGggLSB0aGlzLnBhdHRlcm4ubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhLmZpbGUkXG5cbmNsYXNzIEludmVyc2VTdWZmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2Utc3VmZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXCIoLiopXCJcXCQkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eISguKilcXCQkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9ICF0ZXh0LmVuZHNXaXRoKHRoaXMucGF0dGVybik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRnV6enlNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdHRlcm4sXG4gICAge1xuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVEaWFjcml0aWNzID0gQ29uZmlnLmlnbm9yZURpYWNyaXRpY3MsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICAgIH0gPSB7fVxuICApIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgICB0aGlzLl9iaXRhcFNlYXJjaCA9IG5ldyBCaXRhcFNlYXJjaChwYXR0ZXJuLCB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZURpYWNyaXRpY3MsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2Z1enp5J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRhcFNlYXJjaC5zZWFyY2hJbih0ZXh0KVxuICB9XG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBJbmNsdWRlTWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW5jbHVkZSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eJ1wiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXicoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGxldCBsb2NhdGlvbiA9IDA7XG4gICAgbGV0IGluZGV4O1xuXG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHBhdHRlcm5MZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzXG4gICAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4sIGxvY2F0aW9uKSkgPiAtMSkge1xuICAgICAgbG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG4gICAgICBpbmRpY2VzLnB1c2goW2luZGV4LCBsb2NhdGlvbiAtIDFdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01hdGNoID0gISFpbmRpY2VzLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXNcbiAgICB9XG4gIH1cbn1cblxuLy8g4p2XT3JkZXIgaXMgaW1wb3J0YW50LiBETyBOT1QgQ0hBTkdFLlxuY29uc3Qgc2VhcmNoZXJzID0gW1xuICBFeGFjdE1hdGNoLFxuICBJbmNsdWRlTWF0Y2gsXG4gIFByZWZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCxcbiAgU3VmZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZUV4YWN0TWF0Y2gsXG4gIEZ1enp5TWF0Y2hcbl07XG5cbmNvbnN0IHNlYXJjaGVyc0xlbiA9IHNlYXJjaGVycy5sZW5ndGg7XG5cbi8vIFJlZ2V4IHRvIHNwbGl0IGJ5IHNwYWNlcywgYnV0IGtlZXAgYW55dGhpbmcgaW4gcXVvdGVzIHRvZ2V0aGVyXG5jb25zdCBTUEFDRV9SRSA9IC8gKyg/PSg/OlteXFxcIl0qXFxcIlteXFxcIl0qXFxcIikqW15cXFwiXSokKS87XG5jb25zdCBPUl9UT0tFTiA9ICd8JztcblxuLy8gUmV0dXJuIGEgMkQgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXJ5LCBmb3Igc2ltcGxlciBwYXJzaW5nLlxuLy8gRXhhbXBsZTpcbi8vIFwiXmNvcmUgZ28kIHwgcmIkIHwgcHkkIHh5JFwiID0+IFtbXCJeY29yZVwiLCBcImdvJFwiXSwgW1wicmIkXCJdLCBbXCJweSRcIiwgXCJ4eSRcIl1dXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gcGF0dGVybi5zcGxpdChPUl9UT0tFTikubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IHF1ZXJ5ID0gaXRlbVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KFNQQUNFX1JFKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiAhIWl0ZW0udHJpbSgpKTtcblxuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBxdWVyeUl0ZW0gPSBxdWVyeVtpXTtcblxuICAgICAgLy8gMS4gSGFuZGxlIG11bHRpcGxlIHF1ZXJ5IG1hdGNoIChpLmUsIG9uY2UgdGhhdCBhcmUgcXVvdGVkLCBsaWtlIGBcImhlbGxvIHdvcmxkXCJgKVxuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoIWZvdW5kICYmICsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzTXVsdGlNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBIYW5kbGUgc2luZ2xlIHF1ZXJ5IG1hdGNoZXMgKGkuZSwgb25jZSB0aGF0IGFyZSAqbm90KiBxdW90ZWQpXG4gICAgICBpZHggPSAtMTtcbiAgICAgIHdoaWxlICgrK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc1NpbmdsZU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfSlcbn1cblxuLy8gVGhlc2UgZXh0ZW5kZWQgbWF0Y2hlcnMgY2FuIHJldHVybiBhbiBhcnJheSBvZiBtYXRjaGVzLCBhcyBvcHBvc2VkXG4vLyB0byBhIHNpbmdsIG1hdGNoXG5jb25zdCBNdWx0aU1hdGNoU2V0ID0gbmV3IFNldChbRnV6enlNYXRjaC50eXBlLCBJbmNsdWRlTWF0Y2gudHlwZV0pO1xuXG4vKipcbiAqIENvbW1hbmQtbGlrZSBzZWFyY2hpbmdcbiAqID09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBHaXZlbiBtdWx0aXBsZSBzZWFyY2ggdGVybXMgZGVsaW1pdGVkIGJ5IHNwYWNlcy5lLmcuIGBeanNjcmlwdCAucHl0aG9uJCBydWJ5ICFqYXZhYCxcbiAqIHNlYXJjaCBpbiBhIGdpdmVuIHRleHQuXG4gKlxuICogU2VhcmNoIHN5bnRheDpcbiAqXG4gKiB8IFRva2VuICAgICAgIHwgTWF0Y2ggdHlwZSAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IGBqc2NyaXB0YCAgIHwgZnV6enktbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGZ1enp5IG1hdGNoIGBqc2NyaXB0YCAgICAgICB8XG4gKiB8IGA9c2NoZW1lYCAgIHwgZXhhY3QtbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGFyZSBgc2NoZW1lYCAgICAgICAgICAgICAgICB8XG4gKiB8IGAncHl0aG9uYCAgIHwgaW5jbHVkZS1tYXRjaCAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGluY2x1ZGUgYHB5dGhvbmAgICAgICAgICAgICB8XG4gKiB8IGAhcnVieWAgICAgIHwgaW52ZXJzZS1leGFjdC1tYXRjaCAgICAgICAgfCBJdGVtcyB0aGF0IGRvIG5vdCBpbmNsdWRlIGBydWJ5YCAgICAgICB8XG4gKiB8IGBeamF2YWAgICAgIHwgcHJlZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IHN0YXJ0IHdpdGggYGphdmFgICAgICAgICAgICB8XG4gKiB8IGAhXmVhcmxhbmdgIHwgaW52ZXJzZS1wcmVmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGBlYXJsYW5nYCB8XG4gKiB8IGAuanMkYCAgICAgIHwgc3VmZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IGVuZCB3aXRoIGAuanNgICAgICAgICAgICAgICB8XG4gKiB8IGAhLmdvJGAgICAgIHwgaW52ZXJzZS1zdWZmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBlbmQgd2l0aCBgLmdvYCAgICAgICB8XG4gKlxuICogQSBzaW5nbGUgcGlwZSBjaGFyYWN0ZXIgYWN0cyBhcyBhbiBPUiBvcGVyYXRvci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmdcbiAqIHF1ZXJ5IG1hdGNoZXMgZW50cmllcyB0aGF0IHN0YXJ0IHdpdGggYGNvcmVgIGFuZCBlbmQgd2l0aCBlaXRoZXJgZ29gLCBgcmJgLFxuICogb3JgcHlgLlxuICpcbiAqIGBgYFxuICogXmNvcmUgZ28kIHwgcmIkIHwgcHkkXG4gKiBgYGBcbiAqL1xuY2xhc3MgRXh0ZW5kZWRTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVEaWFjcml0aWNzID0gQ29uZmlnLmlnbm9yZURpYWNyaXRpY3MsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvbixcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2VcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlRGlhY3JpdGljcyxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBpZ25vcmVMb2NhdGlvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuXG4gICAgcGF0dGVybiA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgcGF0dGVybiA9IGlnbm9yZURpYWNyaXRpY3MgPyBzdHJpcERpYWNyaXRpY3MocGF0dGVybikgOiBwYXR0ZXJuO1xuICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgdGhpcy5xdWVyeSA9IHBhcnNlUXVlcnkodGhpcy5wYXR0ZXJuLCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGNvbmRpdGlvbihfLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2hcbiAgfVxuXG4gIHNlYXJjaEluKHRleHQpIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnk7XG5cbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc01hdGNoOiBmYWxzZSxcbiAgICAgICAgc2NvcmU6IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IGluY2x1ZGVNYXRjaGVzLCBpc0Nhc2VTZW5zaXRpdmUsIGlnbm9yZURpYWNyaXRpY3MgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIHRleHQgPSBpc0Nhc2VTZW5zaXRpdmUgPyB0ZXh0IDogdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHRleHQgPSBpZ25vcmVEaWFjcml0aWNzID8gc3RyaXBEaWFjcml0aWNzKHRleHQpIDogdGV4dDtcblxuICAgIGxldCBudW1NYXRjaGVzID0gMDtcbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcblxuICAgIC8vIE9Sc1xuICAgIGZvciAobGV0IGkgPSAwLCBxTGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgcUxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzZWFyY2hlcnMgPSBxdWVyeVtpXTtcblxuICAgICAgLy8gUmVzZXQgaW5kaWNlc1xuICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgbnVtTWF0Y2hlcyA9IDA7XG5cbiAgICAgIC8vIEFORHNcbiAgICAgIGZvciAobGV0IGogPSAwLCBwTGVuID0gc2VhcmNoZXJzLmxlbmd0aDsgaiA8IHBMZW47IGogKz0gMSkge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tqXTtcbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBpbmRpY2VzLCBzY29yZSB9ID0gc2VhcmNoZXIuc2VhcmNoKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbnVtTWF0Y2hlcyArPSAxO1xuICAgICAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG4gICAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc2VhcmNoZXIuY29uc3RydWN0b3IudHlwZTtcbiAgICAgICAgICAgIGlmIChNdWx0aU1hdGNoU2V0Lmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcy5wdXNoKGluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbFNjb3JlID0gMDtcbiAgICAgICAgICBudW1NYXRjaGVzID0gMDtcbiAgICAgICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPUiBjb25kaXRpb24sIHNvIGlmIFRSVUUsIHJldHVyblxuICAgICAgaWYgKG51bU1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICAgIHNjb3JlOiB0b3RhbFNjb3JlIC8gbnVtTWF0Y2hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3RoaW5nIHdhcyBtYXRjaGVkXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgc2NvcmU6IDFcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmVnaXN0ZXJlZFNlYXJjaGVycyA9IFtdO1xuXG5mdW5jdGlvbiByZWdpc3RlciguLi5hcmdzKSB7XG4gIHJlZ2lzdGVyZWRTZWFyY2hlcnMucHVzaCguLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucykge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVnaXN0ZXJlZFNlYXJjaGVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBzZWFyY2hlckNsYXNzID0gcmVnaXN0ZXJlZFNlYXJjaGVyc1tpXTtcbiAgICBpZiAoc2VhcmNoZXJDbGFzcy5jb25kaXRpb24ocGF0dGVybiwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBuZXcgc2VhcmNoZXJDbGFzcyhwYXR0ZXJuLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwgb3B0aW9ucylcbn1cblxuY29uc3QgTG9naWNhbE9wZXJhdG9yID0ge1xuICBBTkQ6ICckYW5kJyxcbiAgT1I6ICckb3InXG59O1xuXG5jb25zdCBLZXlUeXBlID0ge1xuICBQQVRIOiAnJHBhdGgnLFxuICBQQVRURVJOOiAnJHZhbCdcbn07XG5cbmNvbnN0IGlzRXhwcmVzc2lvbiA9IChxdWVyeSkgPT5cbiAgISEocXVlcnlbTG9naWNhbE9wZXJhdG9yLkFORF0gfHwgcXVlcnlbTG9naWNhbE9wZXJhdG9yLk9SXSk7XG5cbmNvbnN0IGlzUGF0aCA9IChxdWVyeSkgPT4gISFxdWVyeVtLZXlUeXBlLlBBVEhdO1xuXG5jb25zdCBpc0xlYWYgPSAocXVlcnkpID0+XG4gICFpc0FycmF5KHF1ZXJ5KSAmJiBpc09iamVjdChxdWVyeSkgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSk7XG5cbmNvbnN0IGNvbnZlcnRUb0V4cGxpY2l0ID0gKHF1ZXJ5KSA9PiAoe1xuICBbTG9naWNhbE9wZXJhdG9yLkFORF06IE9iamVjdC5rZXlzKHF1ZXJ5KS5tYXAoKGtleSkgPT4gKHtcbiAgICBba2V5XTogcXVlcnlba2V5XVxuICB9KSlcbn0pO1xuXG4vLyBXaGVuIGBhdXRvYCBpcyBgdHJ1ZWAsIHRoZSBwYXJzZSBmdW5jdGlvbiB3aWxsIGluZmVyIGFuZCBpbml0aWFsaXplIGFuZCBhZGRcbi8vIHRoZSBhcHByb3ByaWF0ZSBgU2VhcmNoZXJgIGluc3RhbmNlXG5mdW5jdGlvbiBwYXJzZShxdWVyeSwgb3B0aW9ucywgeyBhdXRvID0gdHJ1ZSB9ID0ge30pIHtcbiAgY29uc3QgbmV4dCA9IChxdWVyeSkgPT4ge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMocXVlcnkpO1xuXG4gICAgY29uc3QgaXNRdWVyeVBhdGggPSBpc1BhdGgocXVlcnkpO1xuXG4gICAgaWYgKCFpc1F1ZXJ5UGF0aCAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICAgIHJldHVybiBuZXh0KGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KSlcbiAgICB9XG5cbiAgICBpZiAoaXNMZWFmKHF1ZXJ5KSkge1xuICAgICAgY29uc3Qga2V5ID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVEhdIDoga2V5c1swXTtcblxuICAgICAgY29uc3QgcGF0dGVybiA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRURVJOXSA6IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWShrZXkpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIGtleUlkOiBjcmVhdGVLZXlJZChrZXkpLFxuICAgICAgICBwYXR0ZXJuXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXV0bykge1xuICAgICAgICBvYmouc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIGxldCBub2RlID0ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgb3BlcmF0b3I6IGtleXNbMF1cbiAgICB9O1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV4dChpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBpZiAoIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICBxdWVyeSA9IGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KHF1ZXJ5KVxufVxuXG4vLyBQcmFjdGljYWwgc2NvcmluZyBmdW5jdGlvblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKFxuICByZXN1bHRzLFxuICB7IGlnbm9yZUZpZWxkTm9ybSA9IENvbmZpZy5pZ25vcmVGaWVsZE5vcm0gfVxuKSB7XG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAxO1xuXG4gICAgcmVzdWx0Lm1hdGNoZXMuZm9yRWFjaCgoeyBrZXksIG5vcm0sIHNjb3JlIH0pID0+IHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IGtleSA/IGtleS53ZWlnaHQgOiBudWxsO1xuXG4gICAgICB0b3RhbFNjb3JlICo9IE1hdGgucG93KFxuICAgICAgICBzY29yZSA9PT0gMCAmJiB3ZWlnaHQgPyBOdW1iZXIuRVBTSUxPTiA6IHNjb3JlLFxuICAgICAgICAod2VpZ2h0IHx8IDEpICogKGlnbm9yZUZpZWxkTm9ybSA/IDEgOiBub3JtKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC5zY29yZSA9IHRvdGFsU2NvcmU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXRjaGVzKHJlc3VsdCwgZGF0YSkge1xuICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoZXM7XG4gIGRhdGEubWF0Y2hlcyA9IFtdO1xuXG4gIGlmICghaXNEZWZpbmVkKG1hdGNoZXMpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQobWF0Y2guaW5kaWNlcykgfHwgIW1hdGNoLmluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IGluZGljZXMsIHZhbHVlIH0gPSBtYXRjaDtcblxuICAgIGxldCBvYmogPSB7XG4gICAgICBpbmRpY2VzLFxuICAgICAgdmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKG1hdGNoLmtleSkge1xuICAgICAgb2JqLmtleSA9IG1hdGNoLmtleS5zcmM7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmlkeCA+IC0xKSB7XG4gICAgICBvYmoucmVmSW5kZXggPSBtYXRjaC5pZHg7XG4gICAgfVxuXG4gICAgZGF0YS5tYXRjaGVzLnB1c2gob2JqKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNjb3JlKHJlc3VsdCwgZGF0YSkge1xuICBkYXRhLnNjb3JlID0gcmVzdWx0LnNjb3JlO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoXG4gIHJlc3VsdHMsXG4gIGRvY3MsXG4gIHtcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpbmNsdWRlU2NvcmUgPSBDb25maWcuaW5jbHVkZVNjb3JlXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IFtdO1xuXG4gIGlmIChpbmNsdWRlTWF0Y2hlcykgdHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtTWF0Y2hlcyk7XG4gIGlmIChpbmNsdWRlU2NvcmUpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybVNjb3JlKTtcblxuICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IHsgaWR4IH0gPSByZXN1bHQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgaXRlbTogZG9jc1tpZHhdLFxuICAgICAgcmVmSW5kZXg6IGlkeFxuICAgIH07XG5cbiAgICBpZiAodHJhbnNmb3JtZXJzLmxlbmd0aCkge1xuICAgICAgdHJhbnNmb3JtZXJzLmZvckVhY2goKHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgICAgIHRyYW5zZm9ybWVyKHJlc3VsdCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9KVxufVxuXG5jbGFzcyBGdXNlIHtcbiAgY29uc3RydWN0b3IoZG9jcywgb3B0aW9ucyA9IHt9LCBpbmRleCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uQ29uZmlnLCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2ggJiZcbiAgICAgICF0cnVlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVhURU5ERURfU0VBUkNIX1VOQVZBSUxBQkxFKVxuICAgIH1cblxuICAgIHRoaXMuX2tleVN0b3JlID0gbmV3IEtleVN0b3JlKHRoaXMub3B0aW9ucy5rZXlzKTtcblxuICAgIHRoaXMuc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCk7XG4gIH1cblxuICBzZXRDb2xsZWN0aW9uKGRvY3MsIGluZGV4KSB7XG4gICAgdGhpcy5fZG9jcyA9IGRvY3M7XG5cbiAgICBpZiAoaW5kZXggJiYgIShpbmRleCBpbnN0YW5jZW9mIEZ1c2VJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihJTkNPUlJFQ1RfSU5ERVhfVFlQRSlcbiAgICB9XG5cbiAgICB0aGlzLl9teUluZGV4ID1cbiAgICAgIGluZGV4IHx8XG4gICAgICBjcmVhdGVJbmRleCh0aGlzLm9wdGlvbnMua2V5cywgdGhpcy5fZG9jcywge1xuICAgICAgICBnZXRGbjogdGhpcy5vcHRpb25zLmdldEZuLFxuICAgICAgICBmaWVsZE5vcm1XZWlnaHQ6IHRoaXMub3B0aW9ucy5maWVsZE5vcm1XZWlnaHRcbiAgICAgIH0pO1xuICB9XG5cbiAgYWRkKGRvYykge1xuICAgIGlmICghaXNEZWZpbmVkKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2RvY3MucHVzaChkb2MpO1xuICAgIHRoaXMuX215SW5kZXguYWRkKGRvYyk7XG4gIH1cblxuICByZW1vdmUocHJlZGljYXRlID0gKC8qIGRvYywgaWR4ICovKSA9PiBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9kb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLl9kb2NzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShkb2MsIGkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICAgIGkgLT0gMTtcbiAgICAgICAgbGVuIC09IDE7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMuX2RvY3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgdGhpcy5fbXlJbmRleC5yZW1vdmVBdChpZHgpO1xuICB9XG5cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX215SW5kZXhcbiAgfVxuXG4gIHNlYXJjaChxdWVyeSwgeyBsaW1pdCA9IC0xIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgaW5jbHVkZVNjb3JlLFxuICAgICAgc2hvdWxkU29ydCxcbiAgICAgIHNvcnRGbixcbiAgICAgIGlnbm9yZUZpZWxkTm9ybVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgcmVzdWx0cyA9IGlzU3RyaW5nKHF1ZXJ5KVxuICAgICAgPyBpc1N0cmluZyh0aGlzLl9kb2NzWzBdKVxuICAgICAgICA/IHRoaXMuX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpXG4gICAgICAgIDogdGhpcy5fc2VhcmNoT2JqZWN0TGlzdChxdWVyeSlcbiAgICAgIDogdGhpcy5fc2VhcmNoTG9naWNhbChxdWVyeSk7XG5cbiAgICBjb21wdXRlU2NvcmUocmVzdWx0cywgeyBpZ25vcmVGaWVsZE5vcm0gfSk7XG5cbiAgICBpZiAoc2hvdWxkU29ydCkge1xuICAgICAgcmVzdWx0cy5zb3J0KHNvcnRGbik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKGxpbWl0KSAmJiBsaW1pdCA+IC0xKSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdChyZXN1bHRzLCB0aGlzLl9kb2NzLCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZVxuICAgIH0pXG4gIH1cblxuICBfc2VhcmNoU3RyaW5nTGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBzdHJpbmcgaW4gdGhlIGluZGV4XG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICBpZiAoIWlzRGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgaXRlbTogdGV4dCxcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgbWF0Y2hlczogW3sgc2NvcmUsIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIF9zZWFyY2hMb2dpY2FsKHF1ZXJ5KSB7XG5cbiAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UocXVlcnksIHRoaXMub3B0aW9ucyk7XG5cbiAgICBjb25zdCBldmFsdWF0ZSA9IChub2RlLCBpdGVtLCBpZHgpID0+IHtcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCB7IGtleUlkLCBzZWFyY2hlciB9ID0gbm9kZTtcblxuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgIGtleTogdGhpcy5fa2V5U3RvcmUuZ2V0KGtleUlkKSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5fbXlJbmRleC5nZXRWYWx1ZUZvckl0ZW1BdEtleUlkKGl0ZW0sIGtleUlkKSxcbiAgICAgICAgICBzZWFyY2hlclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXZhbHVhdGUoY2hpbGQsIGl0ZW0sIGlkeCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzLnB1c2goLi4ucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm9wZXJhdG9yID09PSBMb2dpY2FsT3BlcmF0b3IuQU5EKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9O1xuXG4gICAgY29uc3QgcmVjb3JkcyA9IHRoaXMuX215SW5kZXgucmVjb3JkcztcbiAgICBjb25zdCByZXN1bHRNYXAgPSB7fTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmIChpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgbGV0IGV4cFJlc3VsdHMgPSBldmFsdWF0ZShleHByZXNzaW9uLCBpdGVtLCBpZHgpO1xuXG4gICAgICAgIGlmIChleHBSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIERlZHVwZSB3aGVuIGFkZGluZ1xuICAgICAgICAgIGlmICghcmVzdWx0TWFwW2lkeF0pIHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpZHhdID0geyBpZHgsIGl0ZW0sIG1hdGNoZXM6IFtdIH07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0TWFwW2lkeF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBSZXN1bHRzLmZvckVhY2goKHsgbWF0Y2hlcyB9KSA9PiB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XS5tYXRjaGVzLnB1c2goLi4ubWF0Y2hlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoT2JqZWN0TGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyAkOiBpdGVtLCBpOiBpZHggfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBrZXkgKGkuZSwgcGF0aCksIGFuZCBmZXRjaCB0aGUgdmFsdWUgYXQgdGhhdCBrZXlcbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5LCBrZXlJbmRleCkgPT4ge1xuICAgICAgICBtYXRjaGVzLnB1c2goXG4gICAgICAgICAgLi4udGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGl0ZW1ba2V5SW5kZXhdLFxuICAgICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG4gIF9maW5kTWF0Y2hlcyh7IGtleSwgdmFsdWUsIHNlYXJjaGVyIH0pIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKHsgdjogdGV4dCwgaTogaWR4LCBuOiBub3JtIH0pID0+IHtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3JlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICBub3JtLFxuICAgICAgICAgICAgaW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB2OiB0ZXh0LCBuOiBub3JtIH0gPSB2YWx1ZTtcblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7IHNjb3JlLCBrZXksIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzXG4gIH1cbn1cblxuRnVzZS52ZXJzaW9uID0gJzcuMS4wJztcbkZ1c2UuY3JlYXRlSW5kZXggPSBjcmVhdGVJbmRleDtcbkZ1c2UucGFyc2VJbmRleCA9IHBhcnNlSW5kZXg7XG5GdXNlLmNvbmZpZyA9IENvbmZpZztcblxue1xuICBGdXNlLnBhcnNlUXVlcnkgPSBwYXJzZTtcbn1cblxue1xuICByZWdpc3RlcihFeHRlbmRlZFNlYXJjaCk7XG59XG5cbmV4cG9ydCB7IEZ1c2UgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImlzQXJyYXkiLCJ2YWx1ZSIsIkFycmF5IiwiZ2V0VGFnIiwiSU5GSU5JVFkiLCJiYXNlVG9TdHJpbmciLCJyZXN1bHQiLCJ0b1N0cmluZyIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc0Jvb2xlYW4iLCJpc09iamVjdExpa2UiLCJpc09iamVjdCIsImlzRGVmaW5lZCIsInVuZGVmaW5lZCIsImlzQmxhbmsiLCJ0cmltIiwibGVuZ3RoIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiY2FsbCIsIkVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSIsIklOQ09SUkVDVF9JTkRFWF9UWVBFIiwiTE9HSUNBTF9TRUFSQ0hfSU5WQUxJRF9RVUVSWV9GT1JfS0VZIiwia2V5IiwiUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFIiwibWF4IiwiTUlTU0lOR19LRVlfUFJPUEVSVFkiLCJuYW1lIiwiSU5WQUxJRF9LRVlfV0VJR0hUX1ZBTFVFIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJLZXlTdG9yZSIsImNvbnN0cnVjdG9yIiwia2V5cyIsIl9rZXlzIiwiX2tleU1hcCIsInRvdGFsV2VpZ2h0IiwiZm9yRWFjaCIsIm9iaiIsImNyZWF0ZUtleSIsInB1c2giLCJpZCIsIndlaWdodCIsImdldCIsImtleUlkIiwidG9KU09OIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhdGgiLCJzcmMiLCJnZXRGbiIsImNyZWF0ZUtleVBhdGgiLCJjcmVhdGVLZXlJZCIsIkVycm9yIiwic3BsaXQiLCJqb2luIiwibGlzdCIsImFyciIsImRlZXBHZXQiLCJpbmRleCIsImkiLCJsZW4iLCJNYXRjaE9wdGlvbnMiLCJpbmNsdWRlTWF0Y2hlcyIsImZpbmRBbGxNYXRjaGVzIiwibWluTWF0Y2hDaGFyTGVuZ3RoIiwiQmFzaWNPcHRpb25zIiwiaXNDYXNlU2Vuc2l0aXZlIiwiaWdub3JlRGlhY3JpdGljcyIsImluY2x1ZGVTY29yZSIsInNob3VsZFNvcnQiLCJzb3J0Rm4iLCJhIiwiYiIsInNjb3JlIiwiaWR4IiwiRnV6enlPcHRpb25zIiwibG9jYXRpb24iLCJ0aHJlc2hvbGQiLCJkaXN0YW5jZSIsIkFkdmFuY2VkT3B0aW9ucyIsInVzZUV4dGVuZGVkU2VhcmNoIiwiaWdub3JlTG9jYXRpb24iLCJpZ25vcmVGaWVsZE5vcm0iLCJmaWVsZE5vcm1XZWlnaHQiLCJDb25maWciLCJTUEFDRSIsIm5vcm0iLCJtYW50aXNzYSIsImNhY2hlIiwiTWFwIiwibSIsIk1hdGgiLCJwb3ciLCJudW1Ub2tlbnMiLCJtYXRjaCIsImhhcyIsIm4iLCJwYXJzZUZsb2F0Iiwicm91bmQiLCJzZXQiLCJjbGVhciIsIkZ1c2VJbmRleCIsImlzQ3JlYXRlZCIsInNldEluZGV4UmVjb3JkcyIsInNldFNvdXJjZXMiLCJkb2NzIiwicmVjb3JkcyIsInNldEtleXMiLCJfa2V5c01hcCIsImNyZWF0ZSIsImRvYyIsImRvY0luZGV4IiwiX2FkZFN0cmluZyIsIl9hZGRPYmplY3QiLCJhZGQiLCJzaXplIiwicmVtb3ZlQXQiLCJzcGxpY2UiLCJnZXRWYWx1ZUZvckl0ZW1BdEtleUlkIiwiaXRlbSIsInJlY29yZCIsInYiLCIkIiwia2V5SW5kZXgiLCJzdWJSZWNvcmRzIiwic3RhY2siLCJuZXN0ZWRBcnJJbmRleCIsInBvcCIsInN1YlJlY29yZCIsImsiLCJjcmVhdGVJbmRleCIsIm15SW5kZXgiLCJtYXAiLCJwYXJzZUluZGV4IiwiZGF0YSIsImNvbXB1dGVTY29yZSQxIiwicGF0dGVybiIsImVycm9ycyIsImN1cnJlbnRMb2NhdGlvbiIsImV4cGVjdGVkTG9jYXRpb24iLCJhY2N1cmFjeSIsInByb3hpbWl0eSIsImFicyIsImNvbnZlcnRNYXNrVG9JbmRpY2VzIiwibWF0Y2htYXNrIiwiaW5kaWNlcyIsInN0YXJ0IiwiZW5kIiwiTUFYX0JJVFMiLCJzZWFyY2giLCJ0ZXh0IiwicGF0dGVybkFscGhhYmV0IiwicGF0dGVybkxlbiIsInRleHRMZW4iLCJtaW4iLCJjdXJyZW50VGhyZXNob2xkIiwiYmVzdExvY2F0aW9uIiwiY29tcHV0ZU1hdGNoZXMiLCJtYXRjaE1hc2siLCJpbmRleE9mIiwibGFzdEJpdEFyciIsImZpbmFsU2NvcmUiLCJiaW5NYXgiLCJtYXNrIiwiYmluTWluIiwiYmluTWlkIiwiZmxvb3IiLCJmaW5pc2giLCJiaXRBcnIiLCJqIiwiY2hhck1hdGNoIiwiY2hhckF0IiwiaXNNYXRjaCIsImNyZWF0ZVBhdHRlcm5BbHBoYWJldCIsImNoYXIiLCJzdHJpcERpYWNyaXRpY3MiLCJTdHJpbmciLCJub3JtYWxpemUiLCJzdHIiLCJyZXBsYWNlIiwiQml0YXBTZWFyY2giLCJvcHRpb25zIiwidG9Mb3dlckNhc2UiLCJjaHVua3MiLCJhZGRDaHVuayIsInN0YXJ0SW5kZXgiLCJhbHBoYWJldCIsInJlbWFpbmRlciIsInN1YnN0ciIsInNlYXJjaEluIiwiYWxsSW5kaWNlcyIsInRvdGFsU2NvcmUiLCJoYXNNYXRjaGVzIiwiQmFzZU1hdGNoIiwiaXNNdWx0aU1hdGNoIiwiZ2V0TWF0Y2giLCJtdWx0aVJlZ2V4IiwiaXNTaW5nbGVNYXRjaCIsInNpbmdsZVJlZ2V4IiwiZXhwIiwibWF0Y2hlcyIsIkV4YWN0TWF0Y2giLCJ0eXBlIiwiSW52ZXJzZUV4YWN0TWF0Y2giLCJQcmVmaXhFeGFjdE1hdGNoIiwic3RhcnRzV2l0aCIsIkludmVyc2VQcmVmaXhFeGFjdE1hdGNoIiwiU3VmZml4RXhhY3RNYXRjaCIsImVuZHNXaXRoIiwiSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2giLCJGdXp6eU1hdGNoIiwiX2JpdGFwU2VhcmNoIiwiSW5jbHVkZU1hdGNoIiwic2VhcmNoZXJzIiwic2VhcmNoZXJzTGVuIiwiU1BBQ0VfUkUiLCJPUl9UT0tFTiIsInBhcnNlUXVlcnkiLCJxdWVyeSIsImZpbHRlciIsInJlc3VsdHMiLCJxdWVyeUl0ZW0iLCJmb3VuZCIsInNlYXJjaGVyIiwidG9rZW4iLCJNdWx0aU1hdGNoU2V0IiwiU2V0IiwiRXh0ZW5kZWRTZWFyY2giLCJjb25kaXRpb24iLCJfIiwibnVtTWF0Y2hlcyIsInFMZW4iLCJwTGVuIiwicmVnaXN0ZXJlZFNlYXJjaGVycyIsInJlZ2lzdGVyIiwiYXJncyIsImNyZWF0ZVNlYXJjaGVyIiwic2VhcmNoZXJDbGFzcyIsIkxvZ2ljYWxPcGVyYXRvciIsIkFORCIsIk9SIiwiS2V5VHlwZSIsIlBBVEgiLCJQQVRURVJOIiwiaXNFeHByZXNzaW9uIiwiaXNQYXRoIiwiaXNMZWFmIiwiY29udmVydFRvRXhwbGljaXQiLCJwYXJzZSIsImF1dG8iLCJuZXh0IiwiaXNRdWVyeVBhdGgiLCJub2RlIiwiY2hpbGRyZW4iLCJvcGVyYXRvciIsImNvbXB1dGVTY29yZSIsIk51bWJlciIsIkVQU0lMT04iLCJ0cmFuc2Zvcm1NYXRjaGVzIiwicmVmSW5kZXgiLCJ0cmFuc2Zvcm1TY29yZSIsImZvcm1hdCIsInRyYW5zZm9ybWVycyIsInRyYW5zZm9ybWVyIiwiRnVzZSIsIl9rZXlTdG9yZSIsInNldENvbGxlY3Rpb24iLCJfZG9jcyIsIl9teUluZGV4IiwicmVtb3ZlIiwicHJlZGljYXRlIiwiZ2V0SW5kZXgiLCJsaW1pdCIsIl9zZWFyY2hTdHJpbmdMaXN0IiwiX3NlYXJjaE9iamVjdExpc3QiLCJfc2VhcmNoTG9naWNhbCIsInNvcnQiLCJzbGljZSIsImV4cHJlc3Npb24iLCJldmFsdWF0ZSIsIl9maW5kTWF0Y2hlcyIsInJlcyIsImNoaWxkIiwicmVzdWx0TWFwIiwiZXhwUmVzdWx0cyIsInZlcnNpb24iLCJjb25maWciLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/fuse.js@7.1.0/node_modules/fuse.js/dist/fuse.mjs\n");

/***/ })

};
;